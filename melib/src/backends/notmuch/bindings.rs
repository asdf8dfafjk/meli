#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

use libc::time_t;
/* automatically generated by rust-bindgen */
pub type __syscall_slong_t = ::std::os::raw::c_long;

#[doc = " Notmuch boolean type."]
pub type notmuch_bool_t = ::std::os::raw::c_int;
#[doc = " No error occurred."]
pub const _notmuch_status_NOTMUCH_STATUS_SUCCESS: _notmuch_status = 0;
#[doc = " Out of memory."]
pub const _notmuch_status_NOTMUCH_STATUS_OUT_OF_MEMORY: _notmuch_status = 1;
#[doc = " An attempt was made to write to a database opened in read-only"]
#[doc = " mode."]
pub const _notmuch_status_NOTMUCH_STATUS_READ_ONLY_DATABASE: _notmuch_status = 2;
#[doc = " A Xapian exception occurred."]
#[doc = ""]
#[doc = " @todo We don't really want to expose this lame XAPIAN_EXCEPTION"]
#[doc = " value. Instead we should map to things like DATABASE_LOCKED or"]
#[doc = " whatever."]
pub const _notmuch_status_NOTMUCH_STATUS_XAPIAN_EXCEPTION: _notmuch_status = 3;
#[doc = " An error occurred trying to read or write to a file (this could"]
#[doc = " be file not found, permission denied, etc.)"]
pub const _notmuch_status_NOTMUCH_STATUS_FILE_ERROR: _notmuch_status = 4;
#[doc = " A file was presented that doesn't appear to be an email"]
#[doc = " message."]
pub const _notmuch_status_NOTMUCH_STATUS_FILE_NOT_EMAIL: _notmuch_status = 5;
#[doc = " A file contains a message ID that is identical to a message"]
#[doc = " already in the database."]
pub const _notmuch_status_NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID: _notmuch_status = 6;
#[doc = " The user erroneously passed a NULL pointer to a notmuch"]
#[doc = " function."]
pub const _notmuch_status_NOTMUCH_STATUS_NULL_POINTER: _notmuch_status = 7;
#[doc = " A tag value is too long (exceeds NOTMUCH_TAG_MAX)."]
pub const _notmuch_status_NOTMUCH_STATUS_TAG_TOO_LONG: _notmuch_status = 8;
#[doc = " The notmuch_message_thaw function has been called more times"]
#[doc = " than notmuch_message_freeze."]
pub const _notmuch_status_NOTMUCH_STATUS_UNBALANCED_FREEZE_THAW: _notmuch_status = 9;
#[doc = " notmuch_database_end_atomic has been called more times than"]
#[doc = " notmuch_database_begin_atomic."]
pub const _notmuch_status_NOTMUCH_STATUS_UNBALANCED_ATOMIC: _notmuch_status = 10;
#[doc = " The operation is not supported."]
pub const _notmuch_status_NOTMUCH_STATUS_UNSUPPORTED_OPERATION: _notmuch_status = 11;
#[doc = " The operation requires a database upgrade."]
pub const _notmuch_status_NOTMUCH_STATUS_UPGRADE_REQUIRED: _notmuch_status = 12;
#[doc = " There is a problem with the proposed path, e.g. a relative path"]
#[doc = " passed to a function expecting an absolute path."]
pub const _notmuch_status_NOTMUCH_STATUS_PATH_ERROR: _notmuch_status = 13;
#[doc = " The requested operation was ignored. Depending on the function,"]
#[doc = " this may not be an actual error."]
pub const _notmuch_status_NOTMUCH_STATUS_IGNORED: _notmuch_status = 14;
#[doc = " One of the arguments violates the preconditions for the"]
#[doc = " function, in a way not covered by a more specific argument."]
pub const _notmuch_status_NOTMUCH_STATUS_ILLEGAL_ARGUMENT: _notmuch_status = 15;
#[doc = " A MIME object claimed to have cryptographic protection which"]
#[doc = " notmuch tried to handle, but the protocol was not specified in"]
#[doc = " an intelligible way."]
pub const _notmuch_status_NOTMUCH_STATUS_MALFORMED_CRYPTO_PROTOCOL: _notmuch_status = 16;
#[doc = " Notmuch attempted to do crypto processing, but could not"]
#[doc = " initialize the engine needed to do so."]
pub const _notmuch_status_NOTMUCH_STATUS_FAILED_CRYPTO_CONTEXT_CREATION: _notmuch_status = 17;
#[doc = " A MIME object claimed to have cryptographic protection, and"]
#[doc = " notmuch attempted to process it, but the specific protocol was"]
#[doc = " something that notmuch doesn't know how to handle."]
pub const _notmuch_status_NOTMUCH_STATUS_UNKNOWN_CRYPTO_PROTOCOL: _notmuch_status = 18;
#[doc = " Not an actual status value. Just a way to find out how many"]
#[doc = " valid status values there are."]
pub const _notmuch_status_NOTMUCH_STATUS_LAST_STATUS: _notmuch_status = 19;
#[doc = ""]
#[doc = " A zero value (NOTMUCH_STATUS_SUCCESS) indicates that the function"]
#[doc = " completed without error. Any other value indicates an error."]
pub type _notmuch_status = u32;
pub use self::_notmuch_status as notmuch_status_t;
#[doc = " Get a string representation of a notmuch_status_t value."]
#[doc = ""]
#[doc = " The result is read-only."]
pub type notmuch_status_to_string =
    unsafe extern "C" fn(status: notmuch_status_t) -> *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_database {
    _unused: [u8; 0],
}
pub type notmuch_database_t = _notmuch_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_query {
    _unused: [u8; 0],
}
pub type notmuch_query_t = _notmuch_query;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_threads {
    _unused: [u8; 0],
}
pub type notmuch_threads_t = _notmuch_threads;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_thread {
    _unused: [u8; 0],
}
pub type notmuch_thread_t = _notmuch_thread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_messages {
    _unused: [u8; 0],
}
pub type notmuch_messages_t = _notmuch_messages;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_message {
    _unused: [u8; 0],
}
pub type notmuch_message_t = _notmuch_message;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_tags {
    _unused: [u8; 0],
}
pub type notmuch_tags_t = _notmuch_tags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_directory {
    _unused: [u8; 0],
}
pub type notmuch_directory_t = _notmuch_directory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_filenames {
    _unused: [u8; 0],
}
pub type notmuch_filenames_t = _notmuch_filenames;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_config_list {
    _unused: [u8; 0],
}
pub type notmuch_config_list_t = _notmuch_config_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_indexopts {
    _unused: [u8; 0],
}
pub type notmuch_indexopts_t = _notmuch_indexopts;
#[doc = " Create a new, empty notmuch database located at 'path'."]
#[doc = ""]
#[doc = " The path should be a top-level directory to a collection of"]
#[doc = " plain-text email messages (one message per file). This call will"]
#[doc = " create a new \".notmuch\" directory within 'path' where notmuch will"]
#[doc = " store its data."]
#[doc = ""]
#[doc = " After a successful call to notmuch_database_create, the returned"]
#[doc = " database will be open so the caller should call"]
#[doc = " notmuch_database_destroy when finished with it."]
#[doc = ""]
#[doc = " The database will not yet have any data in it"]
#[doc = " (notmuch_database_create itself is a very cheap function). Messages"]
#[doc = " contained within 'path' can be added to the database by calling"]
#[doc = " notmuch_database_index_file."]
#[doc = ""]
#[doc = " In case of any failure, this function returns an error status and"]
#[doc = " sets *database to NULL (after printing an error message on stderr)."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully created the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The given 'path' argument is NULL."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to create the"]
#[doc = "\tdatabase file (such as permission denied, or file not found,"]
#[doc = "\tetc.), or the database already exists."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred."]
pub type notmuch_database_create = unsafe extern "C" fn(
    path: *const ::std::os::raw::c_char,
    database: *mut *mut notmuch_database_t,
) -> notmuch_status_t;

#[doc = " Like notmuch_database_create, except optionally return an error"]
#[doc = " message. This message is allocated by malloc and should be freed by"]
#[doc = " the caller."]
pub type notmuch_database_create_verbose = unsafe extern "C" fn(
    path: *const ::std::os::raw::c_char,
    database: *mut *mut notmuch_database_t,
    error_message: *mut *mut ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Open database for reading only."]
pub const notmuch_database_mode_t_NOTMUCH_DATABASE_MODE_READ_ONLY: notmuch_database_mode_t = 0;
#[doc = " Open database for reading and writing."]
pub const notmuch_database_mode_t_NOTMUCH_DATABASE_MODE_READ_WRITE: notmuch_database_mode_t = 1;
#[doc = " Database open mode for notmuch_database_open."]
pub type notmuch_database_mode_t = u32;
#[doc = " Open an existing notmuch database located at 'path'."]
#[doc = ""]
#[doc = " The database should have been created at some time in the past,"]
#[doc = " (not necessarily by this process), by calling"]
#[doc = " notmuch_database_create with 'path'. By default the database should be"]
#[doc = " opened for reading only. In order to write to the database you need to"]
#[doc = " pass the NOTMUCH_DATABASE_MODE_READ_WRITE mode."]
#[doc = ""]
#[doc = " An existing notmuch database can be identified by the presence of a"]
#[doc = " directory named \".notmuch\" below 'path'."]
#[doc = ""]
#[doc = " The caller should call notmuch_database_destroy when finished with"]
#[doc = " this database."]
#[doc = ""]
#[doc = " In case of any failure, this function returns an error status and"]
#[doc = " sets *database to NULL (after printing an error message on stderr)."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully opened the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The given 'path' argument is NULL."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_FILE_ERROR: An error occurred trying to open the"]
#[doc = "\tdatabase file (such as permission denied, or file not found,"]
#[doc = "\tetc.), or the database version is unknown."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred."]
pub type notmuch_database_open = unsafe extern "C" fn(
    path: *const ::std::os::raw::c_char,
    mode: notmuch_database_mode_t,
    database: *mut *mut notmuch_database_t,
) -> notmuch_status_t;

#[doc = " Like notmuch_database_open, except optionally return an error"]
#[doc = " message. This message is allocated by malloc and should be freed by"]
#[doc = " the caller."]
pub type notmuch_database_open_verbose = unsafe extern "C" fn(
    path: *const ::std::os::raw::c_char,
    mode: notmuch_database_mode_t,
    database: *mut *mut notmuch_database_t,
    error_message: *mut *mut ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Retrieve last status string for given database."]
#[doc = ""]
pub type notmuch_database_status_string =
    unsafe extern "C" fn(notmuch: *const notmuch_database_t) -> *const ::std::os::raw::c_char;

#[doc = " Commit changes and close the given notmuch database."]
#[doc = ""]
#[doc = " After notmuch_database_close has been called, calls to other"]
#[doc = " functions on objects derived from this database may either behave"]
#[doc = " as if the database had not been closed (e.g., if the required data"]
#[doc = " has been cached) or may fail with a"]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION. The only further operation"]
#[doc = " permitted on the database itself is to call"]
#[doc = " notmuch_database_destroy."]
#[doc = ""]
#[doc = " notmuch_database_close can be called multiple times.  Later calls"]
#[doc = " have no effect."]
#[doc = ""]
#[doc = " For writable databases, notmuch_database_close commits all changes"]
#[doc = " to disk before closing the database.  If the caller is currently in"]
#[doc = " an atomic section (there was a notmuch_database_begin_atomic"]
#[doc = " without a matching notmuch_database_end_atomic), this will discard"]
#[doc = " changes made in that atomic section (but still commit changes made"]
#[doc = " prior to entering the atomic section)."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully closed the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred; the"]
#[doc = "\tdatabase has been closed but there are no guarantees the"]
#[doc = "\tchanges to the database, if any, have been flushed to disk."]
pub type notmuch_database_close =
    unsafe extern "C" fn(database: *mut notmuch_database_t) -> notmuch_status_t;

#[doc = " A callback invoked by notmuch_database_compact to notify the user"]
#[doc = " of the progress of the compaction process."]
pub type notmuch_compact_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        message: *const ::std::os::raw::c_char,
        closure: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Compact a notmuch database, backing up the original database to the"]
#[doc = " given path."]
#[doc = ""]
#[doc = " The database will be opened with NOTMUCH_DATABASE_MODE_READ_WRITE"]
#[doc = " during the compaction process to ensure no writes are made."]
#[doc = ""]
#[doc = " If the optional callback function 'status_cb' is non-NULL, it will"]
#[doc = " be called with diagnostic and informational messages. The argument"]
#[doc = " 'closure' is passed verbatim to any callback invoked."]
pub type notmuch_database_compact = unsafe extern "C" fn(
    path: *const ::std::os::raw::c_char,
    backup_path: *const ::std::os::raw::c_char,
    status_cb: notmuch_compact_status_cb_t,
    closure: *mut ::std::os::raw::c_void,
) -> notmuch_status_t;

#[doc = " Destroy the notmuch database, closing it if necessary and freeing"]
#[doc = " all associated resources."]
#[doc = ""]
#[doc = " Return value as in notmuch_database_close if the database was open;"]
#[doc = " notmuch_database_destroy itself has no failure modes."]
pub type notmuch_database_destroy =
    unsafe extern "C" fn(database: *mut notmuch_database_t) -> notmuch_status_t;

#[doc = " Return the database path of the given database."]
#[doc = ""]
#[doc = " The return value is a string owned by notmuch so should not be"]
#[doc = " modified nor freed by the caller."]
pub type notmuch_database_get_path =
    unsafe extern "C" fn(database: *mut notmuch_database_t) -> *const ::std::os::raw::c_char;

#[doc = " Return the database format version of the given database."]
pub type notmuch_database_get_version =
    unsafe extern "C" fn(database: *mut notmuch_database_t) -> ::std::os::raw::c_uint;

#[doc = " Can the database be upgraded to a newer database version?"]
#[doc = ""]
#[doc = " If this function returns TRUE, then the caller may call"]
#[doc = " notmuch_database_upgrade to upgrade the database.  If the caller"]
#[doc = " does not upgrade an out-of-date database, then some functions may"]
#[doc = " fail with NOTMUCH_STATUS_UPGRADE_REQUIRED.  This always returns"]
#[doc = " FALSE for a read-only database because there's no way to upgrade a"]
#[doc = " read-only database."]
pub type notmuch_database_needs_upgrade =
    unsafe extern "C" fn(database: *mut notmuch_database_t) -> notmuch_bool_t;

#[doc = " Upgrade the current database to the latest supported version."]
#[doc = ""]
#[doc = " This ensures that all current notmuch functionality will be"]
#[doc = " available on the database.  After opening a database in read-write"]
#[doc = " mode, it is recommended that clients check if an upgrade is needed"]
#[doc = " (notmuch_database_needs_upgrade) and if so, upgrade with this"]
#[doc = " function before making any modifications.  If"]
#[doc = " notmuch_database_needs_upgrade returns FALSE, this will be a no-op."]
#[doc = ""]
#[doc = " The optional progress_notify callback can be used by the caller to"]
#[doc = " provide progress indication to the user. If non-NULL it will be"]
#[doc = " called periodically with 'progress' as a floating-point value in"]
#[doc = " the range of [0.0 .. 1.0] indicating the progress made so far in"]
#[doc = " the upgrade process.  The argument 'closure' is passed verbatim to"]
#[doc = " any callback invoked."]
pub type notmuch_database_upgrade = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    progress_notify: ::std::option::Option<
        unsafe extern "C" fn(closure: *mut ::std::os::raw::c_void, progress: f64),
    >,
    closure: *mut ::std::os::raw::c_void,
) -> notmuch_status_t;

#[doc = " Begin an atomic database operation."]
#[doc = ""]
#[doc = " Any modifications performed between a successful begin and a"]
#[doc = " notmuch_database_end_atomic will be applied to the database"]
#[doc = " atomically.  Note that, unlike a typical database transaction, this"]
#[doc = " only ensures atomicity, not durability; neither begin nor end"]
#[doc = " necessarily flush modifications to disk."]
#[doc = ""]
#[doc = " Atomic sections may be nested.  begin_atomic and end_atomic must"]
#[doc = " always be called in pairs."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully entered atomic section."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;"]
#[doc = "\tatomic section not entered."]
pub type notmuch_database_begin_atomic =
    unsafe extern "C" fn(notmuch: *mut notmuch_database_t) -> notmuch_status_t;
#[doc = " Indicate the end of an atomic database operation."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully completed atomic section."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;"]
#[doc = "\tatomic section not ended."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UNBALANCED_ATOMIC: The database is not currently in"]
#[doc = "\tan atomic section."]
pub type notmuch_database_end_atomic =
    unsafe extern "C" fn(notmuch: *mut notmuch_database_t) -> notmuch_status_t;
#[doc = " Return the committed database revision and UUID."]
#[doc = ""]
#[doc = " The database revision number increases monotonically with each"]
#[doc = " commit to the database.  Hence, all messages and message changes"]
#[doc = " committed to the database (that is, visible to readers) have a last"]
#[doc = " modification revision <= the committed database revision.  Any"]
#[doc = " messages committed in the future will be assigned a modification"]
#[doc = " revision > the committed database revision."]
#[doc = ""]
#[doc = " The UUID is a NUL-terminated opaque string that uniquely identifies"]
#[doc = " this database.  Two revision numbers are only comparable if they"]
#[doc = " have the same database UUID."]
pub type notmuch_database_get_revision = unsafe extern "C" fn(
    notmuch: *mut notmuch_database_t,
    uuid: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_ulong;

#[doc = " Retrieve a directory object from the database for 'path'."]
#[doc = ""]
#[doc = " Here, 'path' should be a path relative to the path of 'database'"]
#[doc = " (see notmuch_database_get_path), or else should be an absolute path"]
#[doc = " with initial components that match the path of 'database'."]
#[doc = ""]
#[doc = " If this directory object does not exist in the database, this"]
#[doc = " returns NOTMUCH_STATUS_SUCCESS and sets *directory to NULL."]
#[doc = ""]
#[doc = " Otherwise the returned directory object is owned by the database"]
#[doc = " and as such, will only be valid until notmuch_database_destroy is"]
#[doc = " called."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successfully retrieved directory."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The given 'directory' argument is NULL."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred;"]
#[doc = "\tdirectory not retrieved."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the"]
#[doc = "      database to use this function."]
pub type notmuch_database_get_directory = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    path: *const ::std::os::raw::c_char,
    directory: *mut *mut notmuch_directory_t,
) -> notmuch_status_t;

#[doc = " Add a message file to a database, indexing it for retrieval by"]
#[doc = " future searches.  If a message already exists with the same message"]
#[doc = " ID as the specified file, their indexes will be merged, and this"]
#[doc = " new filename will also be associated with the existing message."]
#[doc = ""]
#[doc = " Here, 'filename' should be a path relative to the path of"]
#[doc = " 'database' (see notmuch_database_get_path), or else should be an"]
#[doc = " absolute filename with initial components that match the path of"]
#[doc = " 'database'."]
#[doc = ""]
#[doc = " The file should be a single mail message (not a multi-message mbox)"]
#[doc = " that is expected to remain at its current location, (since the"]
#[doc = " notmuch database will reference the filename, and will not copy the"]
#[doc = " entire contents of the file."]
#[doc = ""]
#[doc = " If another message with the same message ID already exists in the"]
#[doc = " database, rather than creating a new message, this adds the search"]
#[doc = " terms from the identified file to the existing message's index, and"]
#[doc = " adds 'filename' to the list of filenames known for the message."]
#[doc = ""]
#[doc = " The 'indexopts' parameter can be NULL (meaning, use the indexing"]
#[doc = " defaults from the database), or can be an explicit choice of"]
#[doc = " indexing options that should govern the indexing of this specific"]
#[doc = " 'filename'."]
#[doc = ""]
#[doc = " If 'message' is not NULL, then, on successful return"]
#[doc = " (NOTMUCH_STATUS_SUCCESS or NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) '*message'"]
#[doc = " will be initialized to a message object that can be used for things"]
#[doc = " such as adding tags to the just-added message. The user should call"]
#[doc = " notmuch_message_destroy when done with the message. On any failure"]
#[doc = " '*message' will be set to NULL."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Message successfully added to database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred,"]
#[doc = "\tmessage not added."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID: Message has the same message"]
#[doc = "\tID as another message already in the database. The new"]
#[doc = "\tfilename was successfully added to the message in the database"]
#[doc = "\t(if not already present) and the existing message is returned."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_FILE_ERROR: an error occurred trying to open the"]
#[doc = "\tfile, (such as permission denied, or file not found,"]
#[doc = "\tetc.). Nothing added to the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_FILE_NOT_EMAIL: the contents of filename don't look"]
#[doc = "\tlike an email message. Nothing added to the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so no message can be added."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the"]
#[doc = "      database to use this function."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_database_index_file = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    filename: *const ::std::os::raw::c_char,
    indexopts: *mut notmuch_indexopts_t,
    message: *mut *mut notmuch_message_t,
) -> notmuch_status_t;

extern "C" {
    #[doc = " Deprecated alias for notmuch_database_index_file called with"]
    #[doc = " NULL indexopts."]
    #[doc = ""]
    #[doc = " @deprecated Deprecated as of libnotmuch 5.1 (notmuch 0.26). Please"]
    #[doc = " use notmuch_database_index_file instead."]
    #[doc = ""]
    pub fn notmuch_database_add_message(
        database: *mut notmuch_database_t,
        filename: *const ::std::os::raw::c_char,
        message: *mut *mut notmuch_message_t,
    ) -> notmuch_status_t;
}
#[doc = " Remove a message filename from the given notmuch database. If the"]
#[doc = " message has no more filenames, remove the message."]
#[doc = ""]
#[doc = " If the same message (as determined by the message ID) is still"]
#[doc = " available via other filenames, then the message will persist in the"]
#[doc = " database for those filenames. When the last filename is removed for"]
#[doc = " a particular message, the database content for that message will be"]
#[doc = " entirely removed."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: The last filename was removed and the"]
#[doc = "\tmessage was removed from the database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred,"]
#[doc = "\tmessage not removed."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID: This filename was removed but"]
#[doc = "\tthe message persists in the database with at least one other"]
#[doc = "\tfilename."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so no message can be removed."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the"]
#[doc = "      database to use this function."]
pub type notmuch_database_remove_message = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    filename: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Find a message with the given message_id."]
#[doc = ""]
#[doc = " If a message with the given message_id is found then, on successful return"]
#[doc = " (NOTMUCH_STATUS_SUCCESS) '*message' will be initialized to a message"]
#[doc = " object.  The caller should call notmuch_message_destroy when done with the"]
#[doc = " message."]
#[doc = ""]
#[doc = " On any failure or when the message is not found, this function initializes"]
#[doc = " '*message' to NULL. This means, when NOTMUCH_STATUS_SUCCESS is returned, the"]
#[doc = " caller is supposed to check '*message' for NULL to find out whether the"]
#[doc = " message with the given message_id was found."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successful return, check '*message'."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The given 'message' argument is NULL"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory, creating message object"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred"]
pub type notmuch_database_find_message = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    message_id: *const ::std::os::raw::c_char,
    message: *mut *mut notmuch_message_t,
) -> notmuch_status_t;

#[doc = " Find a message with the given filename."]
#[doc = ""]
#[doc = " If the database contains a message with the given filename then, on"]
#[doc = " successful return (NOTMUCH_STATUS_SUCCESS) '*message' will be initialized to"]
#[doc = " a message object. The caller should call notmuch_message_destroy when done"]
#[doc = " with the message."]
#[doc = ""]
#[doc = " On any failure or when the message is not found, this function initializes"]
#[doc = " '*message' to NULL. This means, when NOTMUCH_STATUS_SUCCESS is returned, the"]
#[doc = " caller is supposed to check '*message' for NULL to find out whether the"]
#[doc = " message with the given filename is found."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Successful return, check '*message'"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The given 'message' argument is NULL"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_OUT_OF_MEMORY: Out of memory, creating the message object"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception occurred"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UPGRADE_REQUIRED: The caller must upgrade the"]
#[doc = "      database to use this function."]
pub type notmuch_database_find_message_by_filename = unsafe extern "C" fn(
    notmuch: *mut notmuch_database_t,
    filename: *const ::std::os::raw::c_char,
    message: *mut *mut notmuch_message_t,
) -> notmuch_status_t;

#[doc = " Return a list of all tags found in the database."]
#[doc = ""]
#[doc = " This function creates a list of all tags found in the database. The"]
#[doc = " resulting list contains all tags from all messages found in the database."]
#[doc = ""]
#[doc = " On error this function returns NULL."]
pub type notmuch_database_get_all_tags =
    unsafe extern "C" fn(db: *mut notmuch_database_t) -> *mut notmuch_tags_t;

#[doc = " Create a new query for 'database'."]
#[doc = ""]
#[doc = " Here, 'database' should be an open database, (see"]
#[doc = " notmuch_database_open and notmuch_database_create)."]
#[doc = ""]
#[doc = " For the query string, we'll document the syntax here more"]
#[doc = " completely in the future, but it's likely to be a specialized"]
#[doc = " version of the general Xapian query syntax:"]
#[doc = ""]
#[doc = " https://xapian.org/docs/queryparser.html"]
#[doc = ""]
#[doc = " As a special case, passing either a length-zero string, (that is \"\"),"]
#[doc = " or a string consisting of a single asterisk (that is \"*\"), will"]
#[doc = " result in a query that returns all messages in the database."]
#[doc = ""]
#[doc = " See notmuch_query_set_sort for controlling the order of results."]
#[doc = " See notmuch_query_search_messages and notmuch_query_search_threads"]
#[doc = " to actually execute the query."]
#[doc = ""]
#[doc = " User should call notmuch_query_destroy when finished with this"]
#[doc = " query."]
#[doc = ""]
#[doc = " Will return NULL if insufficient memory is available."]
pub type notmuch_query_create = unsafe extern "C" fn(
    database: *mut notmuch_database_t,
    query_string: *const ::std::os::raw::c_char,
) -> *mut notmuch_query_t;

#[doc = " Oldest first."]
pub const notmuch_sort_t_NOTMUCH_SORT_OLDEST_FIRST: notmuch_sort_t = 0;
#[doc = " Newest first."]
pub const notmuch_sort_t_NOTMUCH_SORT_NEWEST_FIRST: notmuch_sort_t = 1;
#[doc = " Sort by message-id."]
pub const notmuch_sort_t_NOTMUCH_SORT_MESSAGE_ID: notmuch_sort_t = 2;
#[doc = " Do not sort."]
pub const notmuch_sort_t_NOTMUCH_SORT_UNSORTED: notmuch_sort_t = 3;
#[doc = " Sort values for notmuch_query_set_sort."]
pub type notmuch_sort_t = u32;
#[doc = " Return the query_string of this query. See notmuch_query_create."]
pub type notmuch_query_get_query_string =
    unsafe extern "C" fn(query: *const notmuch_query_t) -> *const ::std::os::raw::c_char;

#[doc = " Return the notmuch database of this query. See notmuch_query_create."]
pub type notmuch_query_get_database =
    unsafe extern "C" fn(query: *const notmuch_query_t) -> *mut notmuch_database_t;

pub const notmuch_exclude_t_NOTMUCH_EXCLUDE_FLAG: notmuch_exclude_t = 0;
pub const notmuch_exclude_t_NOTMUCH_EXCLUDE_TRUE: notmuch_exclude_t = 1;
pub const notmuch_exclude_t_NOTMUCH_EXCLUDE_FALSE: notmuch_exclude_t = 2;
pub const notmuch_exclude_t_NOTMUCH_EXCLUDE_ALL: notmuch_exclude_t = 3;
#[doc = " Exclude values for notmuch_query_set_omit_excluded. The strange"]
#[doc = " order is to maintain backward compatibility: the old FALSE/TRUE"]
#[doc = " options correspond to the new"]
#[doc = " NOTMUCH_EXCLUDE_FLAG/NOTMUCH_EXCLUDE_TRUE options."]
pub type notmuch_exclude_t = u32;
#[doc = " Specify whether to omit excluded results or simply flag them.  By"]
#[doc = " default, this is set to TRUE."]
#[doc = ""]
#[doc = " If set to TRUE or ALL, notmuch_query_search_messages will omit excluded"]
#[doc = " messages from the results, and notmuch_query_search_threads will omit"]
#[doc = " threads that match only in excluded messages.  If set to TRUE,"]
#[doc = " notmuch_query_search_threads will include all messages in threads that"]
#[doc = " match in at least one non-excluded message.  Otherwise, if set to ALL,"]
#[doc = " notmuch_query_search_threads will omit excluded messages from all threads."]
#[doc = ""]
#[doc = " If set to FALSE or FLAG then both notmuch_query_search_messages and"]
#[doc = " notmuch_query_search_threads will return all matching"]
#[doc = " messages/threads regardless of exclude status. If set to FLAG then"]
#[doc = " the exclude flag will be set for any excluded message that is"]
#[doc = " returned by notmuch_query_search_messages, and the thread counts"]
#[doc = " for threads returned by notmuch_query_search_threads will be the"]
#[doc = " number of non-excluded messages/matches. Otherwise, if set to"]
#[doc = " FALSE, then the exclude status is completely ignored."]
#[doc = ""]
#[doc = " The performance difference when calling"]
#[doc = " notmuch_query_search_messages should be relatively small (and both"]
#[doc = " should be very fast).  However, in some cases,"]
#[doc = " notmuch_query_search_threads is very much faster when omitting"]
#[doc = " excluded messages as it does not need to construct the threads that"]
#[doc = " only match in excluded messages."]
pub type notmuch_query_set_omit_excluded =
    unsafe extern "C" fn(query: *mut notmuch_query_t, omit_excluded: notmuch_exclude_t);

#[doc = " Specify the sorting desired for this query."]
pub type notmuch_query_set_sort =
    unsafe extern "C" fn(query: *mut notmuch_query_t, sort: notmuch_sort_t);

#[doc = " Return the sort specified for this query. See"]
#[doc = " notmuch_query_set_sort."]
pub type notmuch_query_get_sort =
    unsafe extern "C" fn(query: *const notmuch_query_t) -> notmuch_sort_t;

#[doc = " Add a tag that will be excluded from the query results by default."]
#[doc = " This exclusion will be ignored if this tag appears explicitly in"]
#[doc = " the query."]
#[doc = ""]
#[doc = " @returns"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: excluded was added successfully."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred."]
#[doc = "      Most likely a problem lazily parsing the query string."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_IGNORED: tag is explicitly present in the query, so"]
#[doc = "\t\tnot excluded."]
pub type notmuch_query_add_tag_exclude = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    tag: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Execute a query for threads, returning a notmuch_threads_t object"]
#[doc = " which can be used to iterate over the results. The returned threads"]
#[doc = " object is owned by the query and as such, will only be valid until"]
#[doc = " notmuch_query_destroy."]
#[doc = ""]
#[doc = " Typical usage might be:"]
#[doc = ""]
#[doc = "```text"]
#[doc = "     notmuch_query_t *query;"]
#[doc = "     notmuch_threads_t *threads;"]
#[doc = "     notmuch_thread_t *thread;"]
#[doc = "     notmuch_status_t stat;"]
#[doc = ""]
#[doc = "     query = notmuch_query_create (database, query_string);"]
#[doc = ""]
#[doc = "     for (stat = notmuch_query_search_threads (query, &threads);"]
#[doc = "\t    stat == NOTMUCH_STATUS_SUCCESS &&"]
#[doc = "          notmuch_threads_valid (threads);"]
#[doc = "          notmuch_threads_move_to_next (threads))"]
#[doc = "     {"]
#[doc = "         thread = notmuch_threads_get (threads);"]
#[doc = "         ...."]
#[doc = "         notmuch_thread_destroy (thread);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     notmuch_query_destroy (query);"]
#[doc = "```"]
#[doc = ""]
#[doc = " Note: If you are finished with a thread before its containing"]
#[doc = " query, you can call notmuch_thread_destroy to clean up some memory"]
#[doc = " sooner (as in the above example). Otherwise, if your thread objects"]
#[doc = " are long-lived, then you don't need to call notmuch_thread_destroy"]
#[doc = " and all the memory will still be reclaimed when the query is"]
#[doc = " destroyed."]
#[doc = ""]
#[doc = " Note that there's no explicit destructor needed for the"]
#[doc = " notmuch_threads_t object. (For consistency, we do provide a"]
#[doc = " notmuch_threads_destroy function, but there's no good reason"]
#[doc = " to call it if the query is about to be destroyed)."]
#[doc = ""]
#[doc = " @since libnotmuch 5.0 (notmuch 0.25)"]
pub type notmuch_query_search_threads = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    out: *mut *mut notmuch_threads_t,
) -> notmuch_status_t;

#[doc = " Deprecated alias for notmuch_query_search_threads."]
#[doc = ""]
#[doc = " @deprecated Deprecated as of libnotmuch 5 (notmuch 0.25). Please"]
#[doc = " use notmuch_query_search_threads instead."]
#[doc = ""]
pub type notmuch_query_search_threads_st = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    out: *mut *mut notmuch_threads_t,
) -> notmuch_status_t;

#[doc = " Execute a query for messages, returning a notmuch_messages_t object"]
#[doc = " which can be used to iterate over the results. The returned"]
#[doc = " messages object is owned by the query and as such, will only be"]
#[doc = " valid until notmuch_query_destroy."]
#[doc = ""]
#[doc = " Typical usage might be:"]
#[doc = ""]
#[doc = "```text"]
#[doc = "     notmuch_query_t *query;"]
#[doc = "     notmuch_messages_t *messages;"]
#[doc = "     notmuch_message_t *message;"]
#[doc = ""]
#[doc = "     query = notmuch_query_create (database, query_string);"]
#[doc = ""]
#[doc = "     for (messages = notmuch_query_search_messages (query);"]
#[doc = "          notmuch_messages_valid (messages);"]
#[doc = "          notmuch_messages_move_to_next (messages))"]
#[doc = "     {"]
#[doc = "         message = notmuch_messages_get (messages);"]
#[doc = "         ...."]
#[doc = "         notmuch_message_destroy (message);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     notmuch_query_destroy (query);"]
#[doc = "```"]
#[doc = ""]
#[doc = " Note: If you are finished with a message before its containing"]
#[doc = " query, you can call notmuch_message_destroy to clean up some memory"]
#[doc = " sooner (as in the above example). Otherwise, if your message"]
#[doc = " objects are long-lived, then you don't need to call"]
#[doc = " notmuch_message_destroy and all the memory will still be reclaimed"]
#[doc = " when the query is destroyed."]
#[doc = ""]
#[doc = " Note that there's no explicit destructor needed for the"]
#[doc = " notmuch_messages_t object. (For consistency, we do provide a"]
#[doc = " notmuch_messages_destroy function, but there's no good"]
#[doc = " reason to call it if the query is about to be destroyed)."]
#[doc = ""]
#[doc = " If a Xapian exception occurs this function will return NULL."]
#[doc = ""]
#[doc = " @since libnotmuch 5 (notmuch 0.25)"]
pub type notmuch_query_search_messages = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    out: *mut *mut notmuch_messages_t,
) -> notmuch_status_t;

#[doc = " Deprecated alias for notmuch_query_search_messages"]
#[doc = ""]
#[doc = " @deprecated Deprecated as of libnotmuch 5 (notmuch 0.25). Please use"]
#[doc = " notmuch_query_search_messages instead."]
#[doc = ""]
pub type notmuch_query_search_messages_st = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    out: *mut *mut notmuch_messages_t,
) -> notmuch_status_t;

#[doc = " Destroy a notmuch_query_t along with any associated resources."]
#[doc = ""]
#[doc = " This will in turn destroy any notmuch_threads_t and"]
#[doc = " notmuch_messages_t objects generated by this query, (and in"]
#[doc = " turn any notmuch_thread_t and notmuch_message_t objects generated"]
#[doc = " from those results, etc.), if such objects haven't already been"]
#[doc = " destroyed."]
pub type notmuch_query_destroy = unsafe extern "C" fn(query: *mut notmuch_query_t);

#[doc = " Is the given 'threads' iterator pointing at a valid thread."]
#[doc = ""]
#[doc = " When this function returns TRUE, notmuch_threads_get will return a"]
#[doc = " valid object. Whereas when this function returns FALSE,"]
#[doc = " notmuch_threads_get will return NULL."]
#[doc = ""]
#[doc = " If passed a NULL pointer, this function returns FALSE"]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_threads for example"]
#[doc = " code showing how to iterate over a notmuch_threads_t object."]
pub type notmuch_threads_valid =
    unsafe extern "C" fn(threads: *mut notmuch_threads_t) -> notmuch_bool_t;

#[doc = " Get the current thread from 'threads' as a notmuch_thread_t."]
#[doc = ""]
#[doc = " Note: The returned thread belongs to 'threads' and has a lifetime"]
#[doc = " identical to it (and the query to which it belongs)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_threads for example"]
#[doc = " code showing how to iterate over a notmuch_threads_t object."]
#[doc = ""]
#[doc = " If an out-of-memory situation occurs, this function will return"]
#[doc = " NULL."]
pub type notmuch_threads_get =
    unsafe extern "C" fn(threads: *mut notmuch_threads_t) -> *mut notmuch_thread_t;

#[doc = " Move the 'threads' iterator to the next thread."]
#[doc = ""]
#[doc = " If 'threads' is already pointing at the last thread then the"]
#[doc = " iterator will be moved to a point just beyond that last thread,"]
#[doc = " (where notmuch_threads_valid will return FALSE and"]
#[doc = " notmuch_threads_get will return NULL)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_threads for example"]
#[doc = " code showing how to iterate over a notmuch_threads_t object."]
pub type notmuch_threads_move_to_next = unsafe extern "C" fn(threads: *mut notmuch_threads_t);

#[doc = " Destroy a notmuch_threads_t object."]
#[doc = ""]
#[doc = " It's not strictly necessary to call this function. All memory from"]
#[doc = " the notmuch_threads_t object will be reclaimed when the"]
#[doc = " containing query object is destroyed."]
pub type notmuch_threads_destroy = unsafe extern "C" fn(threads: *mut notmuch_threads_t);

#[doc = " Return the number of messages matching a search."]
#[doc = ""]
#[doc = " This function performs a search and returns the number of matching"]
#[doc = " messages."]
#[doc = ""]
#[doc = " @returns"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: query completed successfully."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred. The"]
#[doc = "      value of *count is not defined."]
#[doc = ""]
#[doc = " @since libnotmuch 5 (notmuch 0.25)"]
pub type notmuch_query_count_messages = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    count: *mut ::std::os::raw::c_uint,
) -> notmuch_status_t;

#[doc = " Deprecated alias for notmuch_query_count_messages"]
#[doc = ""]
#[doc = ""]
#[doc = " @deprecated Deprecated since libnotmuch 5.0 (notmuch 0.25). Please"]
#[doc = " use notmuch_query_count_messages instead."]
pub type notmuch_query_count_messages_st = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    count: *mut ::std::os::raw::c_uint,
) -> notmuch_status_t;

#[doc = " Return the number of threads matching a search."]
#[doc = ""]
#[doc = " This function performs a search and returns the number of unique thread IDs"]
#[doc = " in the matching messages. This is the same as number of threads matching a"]
#[doc = " search."]
#[doc = ""]
#[doc = " Note that this is a significantly heavier operation than"]
#[doc = " notmuch_query_count_messages{_st}()."]
#[doc = ""]
#[doc = " @returns"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_OUT_OF_MEMORY: Memory allocation failed. The value"]
#[doc = "      of *count is not defined"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: query completed successfully."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: a Xapian exception occurred. The"]
#[doc = "      value of *count is not defined."]
#[doc = ""]
#[doc = " @since libnotmuch 5 (notmuch 0.25)"]
pub type notmuch_query_count_threads = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    count: *mut ::std::os::raw::c_uint,
) -> notmuch_status_t;

#[doc = " Deprecated alias for notmuch_query_count_threads"]
#[doc = ""]
#[doc = " @deprecated Deprecated as of libnotmuch 5.0 (notmuch 0.25). Please"]
#[doc = " use notmuch_query_count_threads_st instead."]
pub type notmuch_query_count_threads_st = unsafe extern "C" fn(
    query: *mut notmuch_query_t,
    count: *mut ::std::os::raw::c_uint,
) -> notmuch_status_t;

#[doc = " Get the thread ID of 'thread'."]
#[doc = ""]
#[doc = " The returned string belongs to 'thread' and as such, should not be"]
#[doc = " modified by the caller and will only be valid for as long as the"]
#[doc = " thread is valid, (which is until notmuch_thread_destroy or until"]
#[doc = " the query from which it derived is destroyed)."]
pub type notmuch_thread_get_thread_id =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *const ::std::os::raw::c_char;

#[doc = " Get the total number of messages in 'thread'."]
#[doc = ""]
#[doc = " This count consists of all messages in the database belonging to"]
#[doc = " this thread. Contrast with notmuch_thread_get_matched_messages() ."]
pub type notmuch_thread_get_total_messages =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> ::std::os::raw::c_int;

#[doc = " Get the total number of files in 'thread'."]
#[doc = ""]
#[doc = " This sums notmuch_message_count_files over all messages in the"]
#[doc = " thread"]
#[doc = " @returns Non-negative integer"]
#[doc = " @since libnotmuch 5.0 (notmuch 0.25)"]
pub type notmuch_thread_get_total_files =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> ::std::os::raw::c_int;

#[doc = " Get a notmuch_messages_t iterator for the top-level messages in"]
#[doc = " 'thread' in oldest-first order."]
#[doc = ""]
#[doc = " This iterator will not necessarily iterate over all of the messages"]
#[doc = " in the thread. It will only iterate over the messages in the thread"]
#[doc = " which are not replies to other messages in the thread."]
#[doc = ""]
#[doc = " The returned list will be destroyed when the thread is destroyed."]
pub type notmuch_thread_get_toplevel_messages =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *mut notmuch_messages_t;

#[doc = " Get a notmuch_thread_t iterator for all messages in 'thread' in"]
#[doc = " oldest-first order."]
#[doc = ""]
#[doc = " The returned list will be destroyed when the thread is destroyed."]
pub type notmuch_thread_get_messages =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *mut notmuch_messages_t;

#[doc = " Get the number of messages in 'thread' that matched the search."]
#[doc = ""]
#[doc = " This count includes only the messages in this thread that were"]
#[doc = " matched by the search from which the thread was created and were"]
#[doc = " not excluded by any exclude tags passed in with the query (see"]
#[doc = " notmuch_query_add_tag_exclude). Contrast with"]
#[doc = " notmuch_thread_get_total_messages() ."]
pub type notmuch_thread_get_matched_messages =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> ::std::os::raw::c_int;

#[doc = " Get the authors of 'thread' as a UTF-8 string."]
#[doc = ""]
#[doc = " The returned string is a comma-separated list of the names of the"]
#[doc = " authors of mail messages in the query results that belong to this"]
#[doc = " thread."]
#[doc = ""]
#[doc = " The string contains authors of messages matching the query first, then"]
#[doc = " non-matched authors (with the two groups separated by '|'). Within"]
#[doc = " each group, authors are ordered by date."]
#[doc = ""]
#[doc = " The returned string belongs to 'thread' and as such, should not be"]
#[doc = " modified by the caller and will only be valid for as long as the"]
#[doc = " thread is valid, (which is until notmuch_thread_destroy or until"]
#[doc = " the query from which it derived is destroyed)."]
pub type notmuch_thread_get_authors =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *const ::std::os::raw::c_char;

#[doc = " Get the subject of 'thread' as a UTF-8 string."]
#[doc = ""]
#[doc = " The subject is taken from the first message (according to the query"]
#[doc = " order---see notmuch_query_set_sort) in the query results that"]
#[doc = " belongs to this thread."]
#[doc = ""]
#[doc = " The returned string belongs to 'thread' and as such, should not be"]
#[doc = " modified by the caller and will only be valid for as long as the"]
#[doc = " thread is valid, (which is until notmuch_thread_destroy or until"]
#[doc = " the query from which it derived is destroyed)."]
pub type notmuch_thread_get_subject =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *const ::std::os::raw::c_char;

#[doc = " Get the date of the oldest message in 'thread' as a time_t value."]
pub type notmuch_thread_get_oldest_date =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> time_t;

#[doc = " Get the date of the newest message in 'thread' as a time_t value."]
pub type notmuch_thread_get_newest_date =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> time_t;

#[doc = " Get the tags for 'thread', returning a notmuch_tags_t object which"]
#[doc = " can be used to iterate over all tags."]
#[doc = ""]
#[doc = " Note: In the Notmuch database, tags are stored on individual"]
#[doc = " messages, not on threads. So the tags returned here will be all"]
#[doc = " tags of the messages which matched the search and which belong to"]
#[doc = " this thread."]
#[doc = ""]
#[doc = " The tags object is owned by the thread and as such, will only be"]
#[doc = " valid for as long as the thread is valid, (for example, until"]
#[doc = " notmuch_thread_destroy or until the query from which it derived is"]
#[doc = " destroyed)."]
#[doc = ""]
#[doc = " Typical usage might be:"]
#[doc = ""]
#[doc = "```text"]
#[doc = "     notmuch_thread_t *thread;"]
#[doc = "     notmuch_tags_t *tags;"]
#[doc = "     const char *tag;"]
#[doc = ""]
#[doc = "     thread = notmuch_threads_get (threads);"]
#[doc = ""]
#[doc = "     for (tags = notmuch_thread_get_tags (thread);"]
#[doc = "          notmuch_tags_valid (tags);"]
#[doc = "          notmuch_tags_move_to_next (tags))"]
#[doc = "     {"]
#[doc = "         tag = notmuch_tags_get (tags);"]
#[doc = "         ...."]
#[doc = "     }"]
#[doc = ""]
#[doc = "     notmuch_thread_destroy (thread);"]
#[doc = "```"]
#[doc = ""]
#[doc = " Note that there's no explicit destructor needed for the"]
#[doc = " notmuch_tags_t object. (For consistency, we do provide a"]
#[doc = " notmuch_tags_destroy function, but there's no good reason to call"]
#[doc = " it if the message is about to be destroyed)."]
pub type notmuch_thread_get_tags =
    unsafe extern "C" fn(thread: *mut notmuch_thread_t) -> *mut notmuch_tags_t;

#[doc = " Destroy a notmuch_thread_t object."]
pub type notmuch_thread_destroy = unsafe extern "C" fn(thread: *mut notmuch_thread_t);

#[doc = " Is the given 'messages' iterator pointing at a valid message."]
#[doc = ""]
#[doc = " When this function returns TRUE, notmuch_messages_get will return a"]
#[doc = " valid object. Whereas when this function returns FALSE,"]
#[doc = " notmuch_messages_get will return NULL."]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_messages for example"]
#[doc = " code showing how to iterate over a notmuch_messages_t object."]
pub type notmuch_messages_valid =
    unsafe extern "C" fn(messages: *mut notmuch_messages_t) -> notmuch_bool_t;

#[doc = " Get the current message from 'messages' as a notmuch_message_t."]
#[doc = ""]
#[doc = " Note: The returned message belongs to 'messages' and has a lifetime"]
#[doc = " identical to it (and the query to which it belongs)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_messages for example"]
#[doc = " code showing how to iterate over a notmuch_messages_t object."]
#[doc = ""]
#[doc = " If an out-of-memory situation occurs, this function will return"]
#[doc = " NULL."]
pub type notmuch_messages_get =
    unsafe extern "C" fn(messages: *mut notmuch_messages_t) -> *mut notmuch_message_t;

#[doc = " Move the 'messages' iterator to the next message."]
#[doc = ""]
#[doc = " If 'messages' is already pointing at the last message then the"]
#[doc = " iterator will be moved to a point just beyond that last message,"]
#[doc = " (where notmuch_messages_valid will return FALSE and"]
#[doc = " notmuch_messages_get will return NULL)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_query_search_messages for example"]
#[doc = " code showing how to iterate over a notmuch_messages_t object."]
pub type notmuch_messages_move_to_next = unsafe extern "C" fn(messages: *mut notmuch_messages_t);

#[doc = " Destroy a notmuch_messages_t object."]
#[doc = ""]
#[doc = " It's not strictly necessary to call this function. All memory from"]
#[doc = " the notmuch_messages_t object will be reclaimed when the containing"]
#[doc = " query object is destroyed."]
pub type notmuch_messages_destroy = unsafe extern "C" fn(messages: *mut notmuch_messages_t);

#[doc = " Return a list of tags from all messages."]
#[doc = ""]
#[doc = " The resulting list is guaranteed not to contain duplicated tags."]
#[doc = ""]
#[doc = " WARNING: You can no longer iterate over messages after calling this"]
#[doc = " function, because the iterator will point at the end of the list."]
#[doc = " We do not have a function to reset the iterator yet and the only"]
#[doc = " way how you can iterate over the list again is to recreate the"]
#[doc = " message list."]
#[doc = ""]
#[doc = " The function returns NULL on error."]
pub type notmuch_messages_collect_tags =
    unsafe extern "C" fn(messages: *mut notmuch_messages_t) -> *mut notmuch_tags_t;

#[doc = " Get the database associated with this message."]
#[doc = ""]
#[doc = " @since libnotmuch 5.2 (notmuch 0.27)"]
pub type notmuch_message_get_database =
    unsafe extern "C" fn(message: *const notmuch_message_t) -> *mut notmuch_database_t;

#[doc = " Get the message ID of 'message'."]
#[doc = ""]
#[doc = " The returned string belongs to 'message' and as such, should not be"]
#[doc = " modified by the caller and will only be valid for as long as the"]
#[doc = " message is valid, (which is until the query from which it derived"]
#[doc = " is destroyed)."]
#[doc = ""]
#[doc = " This function will not return NULL since Notmuch ensures that every"]
#[doc = " message has a unique message ID, (Notmuch will generate an ID for a"]
#[doc = " message if the original file does not contain one)."]
pub type notmuch_message_get_message_id =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *const ::std::os::raw::c_char;

#[doc = " Get the thread ID of 'message'."]
#[doc = ""]
#[doc = " The returned string belongs to 'message' and as such, should not be"]
#[doc = " modified by the caller and will only be valid for as long as the"]
#[doc = " message is valid, (for example, until the user calls"]
#[doc = " notmuch_message_destroy on 'message' or until a query from which it"]
#[doc = " derived is destroyed)."]
#[doc = ""]
#[doc = " This function will not return NULL since Notmuch ensures that every"]
#[doc = " message belongs to a single thread."]
pub type notmuch_message_get_thread_id =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *const ::std::os::raw::c_char;

#[doc = " Get a notmuch_messages_t iterator for all of the replies to"]
#[doc = " 'message'."]
#[doc = ""]
#[doc = " Note: This call only makes sense if 'message' was ultimately"]
#[doc = " obtained from a notmuch_thread_t object, (such as by coming"]
#[doc = " directly from the result of calling notmuch_thread_get_"]
#[doc = " toplevel_messages or by any number of subsequent"]
#[doc = " calls to notmuch_message_get_replies)."]
#[doc = ""]
#[doc = " If 'message' was obtained through some non-thread means, (such as"]
#[doc = " by a call to notmuch_query_search_messages), then this function"]
#[doc = " will return NULL."]
#[doc = ""]
#[doc = " If there are no replies to 'message', this function will return"]
#[doc = " NULL. (Note that notmuch_messages_valid will accept that NULL"]
#[doc = " value as legitimate, and simply return FALSE for it.)"]
#[doc = ""]
#[doc = " The returned list will be destroyed when the thread is destroyed."]
pub type notmuch_message_get_replies =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *mut notmuch_messages_t;

#[doc = " Get the total number of files associated with a message."]
#[doc = " @returns Non-negative integer"]
#[doc = " @since libnotmuch 5.0 (notmuch 0.25)"]
pub type notmuch_message_count_files =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> ::std::os::raw::c_int;

#[doc = " Get a filename for the email corresponding to 'message'."]
#[doc = ""]
#[doc = " The returned filename is an absolute filename, (the initial"]
#[doc = " component will match notmuch_database_get_path() )."]
#[doc = ""]
#[doc = " The returned string belongs to the message so should not be"]
#[doc = " modified or freed by the caller (nor should it be referenced after"]
#[doc = " the message is destroyed)."]
#[doc = ""]
#[doc = " Note: If this message corresponds to multiple files in the mail"]
#[doc = " store, (that is, multiple files contain identical message IDs),"]
#[doc = " this function will arbitrarily return a single one of those"]
#[doc = " filenames. See notmuch_message_get_filenames for returning the"]
#[doc = " complete list of filenames."]
pub type notmuch_message_get_filename =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *const ::std::os::raw::c_char;

#[doc = " Get all filenames for the email corresponding to 'message'."]
#[doc = ""]
#[doc = " Returns a notmuch_filenames_t iterator listing all the filenames"]
#[doc = " associated with 'message'. These files may not have identical"]
#[doc = " content, but each will have the identical Message-ID."]
#[doc = ""]
#[doc = " Each filename in the iterator is an absolute filename, (the initial"]
#[doc = " component will match notmuch_database_get_path() )."]
pub type notmuch_message_get_filenames =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *mut notmuch_filenames_t;

#[doc = " Re-index the e-mail corresponding to 'message' using the supplied index options"]
#[doc = ""]
#[doc = " Returns the status of the re-index operation.  (see the return"]
#[doc = " codes documented in notmuch_database_index_file)"]
#[doc = ""]
#[doc = " After reindexing, the user should discard the message object passed"]
#[doc = " in here by calling notmuch_message_destroy, since it refers to the"]
#[doc = " original message, not to the reindexed message."]
pub type notmuch_message_reindex = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    indexopts: *mut notmuch_indexopts_t,
) -> notmuch_status_t;

pub const _notmuch_message_flag_NOTMUCH_MESSAGE_FLAG_MATCH: _notmuch_message_flag = 0;
pub const _notmuch_message_flag_NOTMUCH_MESSAGE_FLAG_EXCLUDED: _notmuch_message_flag = 1;
pub const _notmuch_message_flag_NOTMUCH_MESSAGE_FLAG_GHOST: _notmuch_message_flag = 2;
#[doc = " Message flags."]
pub type _notmuch_message_flag = u32;
pub use self::_notmuch_message_flag as notmuch_message_flag_t;
#[doc = " Get a value of a flag for the email corresponding to 'message'."]
pub type notmuch_message_get_flag = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    flag: notmuch_message_flag_t,
) -> notmuch_bool_t;

#[doc = " Set a value of a flag for the email corresponding to 'message'."]
pub type notmuch_message_set_flag = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    flag: notmuch_message_flag_t,
    value: notmuch_bool_t,
);

#[doc = " Get the date of 'message' as a time_t value."]
#[doc = ""]
#[doc = " For the original textual representation of the Date header from the"]
#[doc = " message call notmuch_message_get_header() with a header value of"]
#[doc = " \"date\"."]
pub type notmuch_message_get_date = unsafe extern "C" fn(message: *mut notmuch_message_t) -> time_t;

#[doc = " Get the value of the specified header from 'message' as a UTF-8 string."]
#[doc = ""]
#[doc = " Common headers are stored in the database when the message is"]
#[doc = " indexed and will be returned from the database.  Other headers will"]
#[doc = " be read from the actual message file."]
#[doc = ""]
#[doc = " The header name is case insensitive."]
#[doc = ""]
#[doc = " The returned string belongs to the message so should not be"]
#[doc = " modified or freed by the caller (nor should it be referenced after"]
#[doc = " the message is destroyed)."]
#[doc = ""]
#[doc = " Returns an empty string (\"\") if the message does not contain a"]
#[doc = " header line matching 'header'. Returns NULL if any error occurs."]
pub type notmuch_message_get_header = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    header: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char;

#[doc = " Get the tags for 'message', returning a notmuch_tags_t object which"]
#[doc = " can be used to iterate over all tags."]
#[doc = ""]
#[doc = " The tags object is owned by the message and as such, will only be"]
#[doc = " valid for as long as the message is valid, (which is until the"]
#[doc = " query from which it derived is destroyed)."]
#[doc = ""]
#[doc = " Typical usage might be:"]
#[doc = ""]
#[doc = "```text"]
#[doc = "     notmuch_message_t *message;"]
#[doc = "     notmuch_tags_t *tags;"]
#[doc = "     const char *tag;"]
#[doc = ""]
#[doc = "     message = notmuch_database_find_message (database, message_id);"]
#[doc = ""]
#[doc = "     for (tags = notmuch_message_get_tags (message);"]
#[doc = "          notmuch_tags_valid (tags);"]
#[doc = "          notmuch_tags_move_to_next (tags))"]
#[doc = "     {"]
#[doc = "         tag = notmuch_tags_get (tags);"]
#[doc = "         ...."]
#[doc = "     }"]
#[doc = ""]
#[doc = "     notmuch_message_destroy (message);"]
#[doc = "```"]
#[doc = ""]
#[doc = " Note that there's no explicit destructor needed for the"]
#[doc = " notmuch_tags_t object. (For consistency, we do provide a"]
#[doc = " notmuch_tags_destroy function, but there's no good reason to call"]
#[doc = " it if the message is about to be destroyed)."]
pub type notmuch_message_get_tags =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> *mut notmuch_tags_t;

#[doc = " Add a tag to the given message."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Tag successfully added to message"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The 'tag' argument is NULL"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_TAG_TOO_LONG: The length of 'tag' is too long"]
#[doc = "\t(exceeds NOTMUCH_TAG_MAX)"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so message cannot be modified."]
pub type notmuch_message_add_tag = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    tag: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Remove a tag from the given message."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Tag successfully removed from message"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_NULL_POINTER: The 'tag' argument is NULL"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_TAG_TOO_LONG: The length of 'tag' is too long"]
#[doc = "\t(exceeds NOTMUCH_TAG_MAX)"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so message cannot be modified."]
pub type notmuch_message_remove_tag = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    tag: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Remove all tags from the given message."]
#[doc = ""]
#[doc = " See notmuch_message_freeze for an example showing how to safely"]
#[doc = " replace tag values."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so message cannot be modified."]
pub type notmuch_message_remove_all_tags =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> notmuch_status_t;

#[doc = " Add/remove tags according to maildir flags in the message filename(s)."]
#[doc = ""]
#[doc = " This function examines the filenames of 'message' for maildir"]
#[doc = " flags, and adds or removes tags on 'message' as follows when these"]
#[doc = " flags are present:"]
#[doc = ""]
#[doc = "\tFlag\tAction if present"]
#[doc = "\t----\t-----------------"]
#[doc = "\t'D'\tAdds the \"draft\" tag to the message"]
#[doc = "\t'F'\tAdds the \"flagged\" tag to the message"]
#[doc = "\t'P'\tAdds the \"passed\" tag to the message"]
#[doc = "\t'R'\tAdds the \"replied\" tag to the message"]
#[doc = "\t'S'\tRemoves the \"unread\" tag from the message"]
#[doc = ""]
#[doc = " For each flag that is not present, the opposite action (add/remove)"]
#[doc = " is performed for the corresponding tags."]
#[doc = ""]
#[doc = " Flags are identified as trailing components of the filename after a"]
#[doc = " sequence of \":2,\"."]
#[doc = ""]
#[doc = " If there are multiple filenames associated with this message, the"]
#[doc = " flag is considered present if it appears in one or more"]
#[doc = " filenames. (That is, the flags from the multiple filenames are"]
#[doc = " combined with the logical OR operator.)"]
#[doc = ""]
#[doc = " A client can ensure that notmuch database tags remain synchronized"]
#[doc = " with maildir flags by calling this function after each call to"]
#[doc = " notmuch_database_index_file. See also"]
#[doc = " notmuch_message_tags_to_maildir_flags for synchronizing tag changes"]
#[doc = " back to maildir flags."]
pub type notmuch_message_maildir_flags_to_tags =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> notmuch_status_t;

#[doc = " return TRUE if any filename of 'message' has maildir flag 'flag',"]
#[doc = " FALSE otherwise."]
#[doc = ""]
pub type notmuch_message_has_maildir_flag = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    flag: ::std::os::raw::c_char,
) -> notmuch_bool_t;

#[doc = " Rename message filename(s) to encode tags as maildir flags."]
#[doc = ""]
#[doc = " Specifically, for each filename corresponding to this message:"]
#[doc = ""]
#[doc = " If the filename is not in a maildir directory, do nothing.  (A"]
#[doc = " maildir directory is determined as a directory named \"new\" or"]
#[doc = " \"cur\".) Similarly, if the filename has invalid maildir info,"]
#[doc = " (repeated or outof-ASCII-order flag characters after \":2,\"), then"]
#[doc = " do nothing."]
#[doc = ""]
#[doc = " If the filename is in a maildir directory, rename the file so that"]
#[doc = " its filename ends with the sequence \":2,\" followed by zero or more"]
#[doc = " of the following single-character flags (in ASCII order):"]
#[doc = ""]
#[doc = "   * flag 'D' iff the message has the \"draft\" tag"]
#[doc = "   * flag 'F' iff the message has the \"flagged\" tag"]
#[doc = "   * flag 'P' iff the message has the \"passed\" tag"]
#[doc = "   * flag 'R' iff the message has the \"replied\" tag"]
#[doc = "   * flag 'S' iff the message does not have the \"unread\" tag"]
#[doc = ""]
#[doc = " Any existing flags unmentioned in the list above will be preserved"]
#[doc = " in the renaming."]
#[doc = ""]
#[doc = " Also, if this filename is in a directory named \"new\", rename it to"]
#[doc = " be within the neighboring directory named \"cur\"."]
#[doc = ""]
#[doc = " A client can ensure that maildir filename flags remain synchronized"]
#[doc = " with notmuch database tags by calling this function after changing"]
#[doc = " tags, (after calls to notmuch_message_add_tag,"]
#[doc = " notmuch_message_remove_tag, or notmuch_message_freeze/"]
#[doc = " notmuch_message_thaw). See also notmuch_message_maildir_flags_to_tags"]
#[doc = " for synchronizing maildir flag changes back to tags."]
pub type notmuch_message_tags_to_maildir_flags =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> notmuch_status_t;

#[doc = " Freeze the current state of 'message' within the database."]
#[doc = ""]
#[doc = " This means that changes to the message state, (via"]
#[doc = " notmuch_message_add_tag, notmuch_message_remove_tag, and"]
#[doc = " notmuch_message_remove_all_tags), will not be committed to the"]
#[doc = " database until the message is thawed with notmuch_message_thaw."]
#[doc = ""]
#[doc = " Multiple calls to freeze/thaw are valid and these calls will"]
#[doc = " \"stack\". That is there must be as many calls to thaw as to freeze"]
#[doc = " before a message is actually thawed."]
#[doc = ""]
#[doc = " The ability to do freeze/thaw allows for safe transactions to"]
#[doc = " change tag values. For example, explicitly setting a message to"]
#[doc = " have a given set of tags might look like this:"]
#[doc = ""]
#[doc = "    notmuch_message_freeze (message);"]
#[doc = ""]
#[doc = "    notmuch_message_remove_all_tags (message);"]
#[doc = ""]
#[doc = "    for (i = 0; i < NUM_TAGS; i++)"]
#[doc = "        notmuch_message_add_tag (message, tags[i]);"]
#[doc = ""]
#[doc = "    notmuch_message_thaw (message);"]
#[doc = ""]
#[doc = " With freeze/thaw used like this, the message in the database is"]
#[doc = " guaranteed to have either the full set of original tag values, or"]
#[doc = " the full set of new tag values, but nothing in between."]
#[doc = ""]
#[doc = " Imagine the example above without freeze/thaw and the operation"]
#[doc = " somehow getting interrupted. This could result in the message being"]
#[doc = " left with no tags if the interruption happened after"]
#[doc = " notmuch_message_remove_all_tags but before notmuch_message_add_tag."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Message successfully frozen."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so message cannot be modified."]
pub type notmuch_message_freeze =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> notmuch_status_t;

#[doc = " Thaw the current 'message', synchronizing any changes that may have"]
#[doc = " occurred while 'message' was frozen into the notmuch database."]
#[doc = ""]
#[doc = " See notmuch_message_freeze for an example of how to use this"]
#[doc = " function to safely provide tag changes."]
#[doc = ""]
#[doc = " Multiple calls to freeze/thaw are valid and these calls with"]
#[doc = " \"stack\". That is there must be as many calls to thaw as to freeze"]
#[doc = " before a message is actually thawed."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: Message successfully thawed, (or at least"]
#[doc = "\tits frozen count has successfully been reduced by 1)."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_UNBALANCED_FREEZE_THAW: An attempt was made to thaw"]
#[doc = "\tan unfrozen message. That is, there have been an unbalanced"]
#[doc = "\tnumber of calls to notmuch_message_freeze and"]
#[doc = "\tnotmuch_message_thaw."]
pub type notmuch_message_thaw =
    unsafe extern "C" fn(message: *mut notmuch_message_t) -> notmuch_status_t;

#[doc = " Destroy a notmuch_message_t object."]
#[doc = ""]
#[doc = " It can be useful to call this function in the case of a single"]
#[doc = " query object with many messages in the result, (such as iterating"]
#[doc = " over the entire database). Otherwise, it's fine to never call this"]
#[doc = " function and there will still be no memory leaks. (The memory from"]
#[doc = " the messages get reclaimed when the containing query is destroyed.)"]
pub type notmuch_message_destroy = unsafe extern "C" fn(message: *mut notmuch_message_t);

#[doc = " @name Message Properties"]
#[doc = ""]
#[doc = " This interface provides the ability to attach arbitrary (key,value)"]
#[doc = " string pairs to a message, to remove such pairs, and to iterate"]
#[doc = " over them.  The caller should take some care as to what keys they"]
#[doc = " add or delete values for, as other subsystems or extensions may"]
#[doc = " depend on these properties."]
#[doc = ""]
#[doc = " Please see notmuch-properties(7) for more details about specific"]
#[doc = " properties and conventions around their use."]
#[doc = ""]
#[doc = " Retrieve the value for a single property key"]
#[doc = ""]
#[doc = " *value* is set to a string owned by the message or NULL if there is"]
#[doc = " no such key. In the case of multiple values for the given key, the"]
#[doc = " first one is retrieved."]
#[doc = ""]
#[doc = " @returns"]
#[doc = " - NOTMUCH_STATUS_NULL_POINTER: *value* may not be NULL."]
#[doc = " - NOTMUCH_STATUS_SUCCESS: No error occurred."]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_get_property = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    key: *const ::std::os::raw::c_char,
    value: *mut *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Add a (key,value) pair to a message"]
#[doc = ""]
#[doc = " @returns"]
#[doc = " - NOTMUCH_STATUS_ILLEGAL_ARGUMENT: *key* may not contain an '=' character."]
#[doc = " - NOTMUCH_STATUS_NULL_POINTER: Neither *key* nor *value* may be NULL."]
#[doc = " - NOTMUCH_STATUS_SUCCESS: No error occurred."]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_add_property = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Remove a (key,value) pair from a message."]
#[doc = ""]
#[doc = " It is not an error to remove a non-existant (key,value) pair"]
#[doc = ""]
#[doc = " @returns"]
#[doc = " - NOTMUCH_STATUS_ILLEGAL_ARGUMENT: *key* may not contain an '=' character."]
#[doc = " - NOTMUCH_STATUS_NULL_POINTER: Neither *key* nor *value* may be NULL."]
#[doc = " - NOTMUCH_STATUS_SUCCESS: No error occurred."]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_remove_property = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Remove all (key,value) pairs from the given message."]
#[doc = ""]
#[doc = " @param[in,out] message  message to operate on."]
#[doc = " @param[in]     key      key to delete properties for. If NULL, delete"]
#[doc = "\t\t\t   properties for all keys"]
#[doc = " @returns"]
#[doc = " - NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in"]
#[doc = "   read-only mode so message cannot be modified."]
#[doc = " - NOTMUCH_STATUS_SUCCESS: No error occurred."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_remove_all_properties = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    key: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Remove all (prefix*,value) pairs from the given message"]
#[doc = ""]
#[doc = " @param[in,out] message  message to operate on."]
#[doc = " @param[in]     prefix   delete properties with keys that start with prefix."]
#[doc = "\t\t\t   If NULL, delete all properties"]
#[doc = " @returns"]
#[doc = " - NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in"]
#[doc = "   read-only mode so message cannot be modified."]
#[doc = " - NOTMUCH_STATUS_SUCCESS: No error occurred."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_message_remove_all_properties_with_prefix =
    unsafe extern "C" fn(
        message: *mut notmuch_message_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> notmuch_status_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _notmuch_string_map_iterator {
    _unused: [u8; 0],
}
#[doc = " Opaque message property iterator"]
pub type notmuch_message_properties_t = _notmuch_string_map_iterator;
extern "C" {
    #[doc = " Get the properties for *message*, returning a"]
    #[doc = " notmuch_message_properties_t object which can be used to iterate"]
    #[doc = " over all properties."]
    #[doc = ""]
    #[doc = " The notmuch_message_properties_t object is owned by the message and"]
    #[doc = " as such, will only be valid for as long as the message is valid,"]
    #[doc = " (which is until the query from which it derived is destroyed)."]
    #[doc = ""]
    #[doc = " @param[in] message  The message to examine"]
    #[doc = " @param[in] key      key or key prefix"]
    #[doc = " @param[in] exact    if TRUE, require exact match with key. Otherwise"]
    #[doc = "\t\t       treat as prefix."]
    #[doc = ""]
    #[doc = " Typical usage might be:"]
    #[doc = ""]
    #[doc = "```text"]
    #[doc = "     notmuch_message_properties_t *list;"]
    #[doc = ""]
    #[doc = "     for (list = notmuch_message_get_properties (message, \"testkey1\", TRUE);"]
    #[doc = "          notmuch_message_properties_valid (list); notmuch_message_properties_move_to_next (list)) {"]
    #[doc = "        printf(\"%s\\n\", notmuch_message_properties_value(list));"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     notmuch_message_properties_destroy (list);"]
    #[doc = "```"]
    #[doc = ""]
    #[doc = " Note that there's no explicit destructor needed for the"]
    #[doc = " notmuch_message_properties_t object. (For consistency, we do"]
    #[doc = " provide a notmuch_message_properities_destroy function, but there's"]
    #[doc = " no good reason to call it if the message is about to be destroyed)."]
    #[doc = ""]
    #[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
    pub fn notmuch_message_get_properties(
        message: *mut notmuch_message_t,
        key: *const ::std::os::raw::c_char,
        exact: notmuch_bool_t,
    ) -> *mut notmuch_message_properties_t;
}
#[doc = " Return the number of properties named \"key\" belonging to the specific message."]
#[doc = ""]
#[doc = " @param[in] message  The message to examine"]
#[doc = " @param[in] key      key to count"]
#[doc = " @param[out] count   The number of matching properties associated with this message."]
#[doc = ""]
#[doc = " @returns"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: successful count, possibly some other error."]
#[doc = ""]
#[doc = " @since libnotmuch 5.2 (notmuch 0.27)"]
pub type notmuch_message_count_properties = unsafe extern "C" fn(
    message: *mut notmuch_message_t,
    key: *const ::std::os::raw::c_char,
    count: *mut ::std::os::raw::c_uint,
) -> notmuch_status_t;

#[doc = " Is the given *properties* iterator pointing at a valid (key,value)"]
#[doc = " pair."]
#[doc = ""]
#[doc = " When this function returns TRUE,"]
#[doc = " notmuch_message_properties_{key,value} will return a valid string,"]
#[doc = " and notmuch_message_properties_move_to_next will do what it"]
#[doc = " says. Whereas when this function returns FALSE, calling any of"]
#[doc = " these functions results in undefined behaviour."]
#[doc = ""]
#[doc = " See the documentation of notmuch_message_get_properties for example"]
#[doc = " code showing how to iterate over a notmuch_message_properties_t"]
#[doc = " object."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_properties_valid =
    unsafe extern "C" fn(properties: *mut notmuch_message_properties_t) -> notmuch_bool_t;

#[doc = " Move the *properties* iterator to the next (key,value) pair"]
#[doc = ""]
#[doc = " If *properties* is already pointing at the last pair then the iterator"]
#[doc = " will be moved to a point just beyond that last pair, (where"]
#[doc = " notmuch_message_properties_valid will return FALSE)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_message_get_properties for example"]
#[doc = " code showing how to iterate over a notmuch_message_properties_t object."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_properties_move_to_next =
    unsafe extern "C" fn(properties: *mut notmuch_message_properties_t);

#[doc = " Return the key from the current (key,value) pair."]
#[doc = ""]
#[doc = " this could be useful if iterating for a prefix"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_properties_key = unsafe extern "C" fn(
    properties: *mut notmuch_message_properties_t,
) -> *const ::std::os::raw::c_char;

#[doc = " Return the value from the current (key,value) pair."]
#[doc = ""]
#[doc = " This could be useful if iterating for a prefix."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_properties_value = unsafe extern "C" fn(
    properties: *mut notmuch_message_properties_t,
) -> *const ::std::os::raw::c_char;

#[doc = " Destroy a notmuch_message_properties_t object."]
#[doc = ""]
#[doc = " It's not strictly necessary to call this function. All memory from"]
#[doc = " the notmuch_message_properties_t object will be reclaimed when the"]
#[doc = " containing message object is destroyed."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_message_properties_destroy =
    unsafe extern "C" fn(properties: *mut notmuch_message_properties_t);

#[doc = " Is the given 'tags' iterator pointing at a valid tag."]
#[doc = ""]
#[doc = " When this function returns TRUE, notmuch_tags_get will return a"]
#[doc = " valid string. Whereas when this function returns FALSE,"]
#[doc = " notmuch_tags_get will return NULL."]
#[doc = ""]
#[doc = " See the documentation of notmuch_message_get_tags for example code"]
#[doc = " showing how to iterate over a notmuch_tags_t object."]
pub type notmuch_tags_valid = unsafe extern "C" fn(tags: *mut notmuch_tags_t) -> notmuch_bool_t;

#[doc = " Get the current tag from 'tags' as a string."]
#[doc = ""]
#[doc = " Note: The returned string belongs to 'tags' and has a lifetime"]
#[doc = " identical to it (and the query to which it ultimately belongs)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_message_get_tags for example code"]
#[doc = " showing how to iterate over a notmuch_tags_t object."]
pub type notmuch_tags_get =
    unsafe extern "C" fn(tags: *mut notmuch_tags_t) -> *const ::std::os::raw::c_char;

#[doc = " Move the 'tags' iterator to the next tag."]
#[doc = ""]
#[doc = " If 'tags' is already pointing at the last tag then the iterator"]
#[doc = " will be moved to a point just beyond that last tag, (where"]
#[doc = " notmuch_tags_valid will return FALSE and notmuch_tags_get will"]
#[doc = " return NULL)."]
#[doc = ""]
#[doc = " See the documentation of notmuch_message_get_tags for example code"]
#[doc = " showing how to iterate over a notmuch_tags_t object."]
pub type notmuch_tags_move_to_next = unsafe extern "C" fn(tags: *mut notmuch_tags_t);

#[doc = " Destroy a notmuch_tags_t object."]
#[doc = ""]
#[doc = " It's not strictly necessary to call this function. All memory from"]
#[doc = " the notmuch_tags_t object will be reclaimed when the containing"]
#[doc = " message or query objects are destroyed."]
pub type notmuch_tags_destroy = unsafe extern "C" fn(tags: *mut notmuch_tags_t);

#[doc = " Store an mtime within the database for 'directory'."]
#[doc = ""]
#[doc = " The 'directory' should be an object retrieved from the database"]
#[doc = " with notmuch_database_get_directory for a particular path."]
#[doc = ""]
#[doc = " The intention is for the caller to use the mtime to allow efficient"]
#[doc = " identification of new messages to be added to the database. The"]
#[doc = " recommended usage is as follows:"]
#[doc = ""]
#[doc = "   o Read the mtime of a directory from the filesystem"]
#[doc = ""]
#[doc = "   o Call index_file for all mail files in the directory"]
#[doc = ""]
#[doc = "   o Call notmuch_directory_set_mtime with the mtime read from the"]
#[doc = "     filesystem."]
#[doc = ""]
#[doc = " Then, when wanting to check for updates to the directory in the"]
#[doc = " future, the client can call notmuch_directory_get_mtime and know"]
#[doc = " that it only needs to add files if the mtime of the directory and"]
#[doc = " files are newer than the stored timestamp."]
#[doc = ""]
#[doc = " Note: The notmuch_directory_get_mtime function does not allow the"]
#[doc = " caller to distinguish a timestamp of 0 from a non-existent"]
#[doc = " timestamp. So don't store a timestamp of 0 unless you are"]
#[doc = " comfortable with that."]
#[doc = ""]
#[doc = " Return value:"]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_SUCCESS: mtime successfully stored in database."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_XAPIAN_EXCEPTION: A Xapian exception"]
#[doc = "\toccurred, mtime not stored."]
#[doc = ""]
#[doc = " NOTMUCH_STATUS_READ_ONLY_DATABASE: Database was opened in read-only"]
#[doc = "\tmode so directory mtime cannot be modified."]
pub type notmuch_directory_set_mtime =
    unsafe extern "C" fn(directory: *mut notmuch_directory_t, mtime: time_t) -> notmuch_status_t;

#[doc = " Get the mtime of a directory, (as previously stored with"]
#[doc = " notmuch_directory_set_mtime)."]
#[doc = ""]
#[doc = " Returns 0 if no mtime has previously been stored for this"]
#[doc = " directory."]
pub type notmuch_directory_get_mtime =
    unsafe extern "C" fn(directory: *mut notmuch_directory_t) -> time_t;

#[doc = " Get a notmuch_filenames_t iterator listing all the filenames of"]
#[doc = " messages in the database within the given directory."]
#[doc = ""]
#[doc = " The returned filenames will be the basename-entries only (not"]
#[doc = " complete paths)."]
pub type notmuch_directory_get_child_files =
    unsafe extern "C" fn(directory: *mut notmuch_directory_t) -> *mut notmuch_filenames_t;

#[doc = " Get a notmuch_filenames_t iterator listing all the filenames of"]
#[doc = " sub-directories in the database within the given directory."]
#[doc = ""]
#[doc = " The returned filenames will be the basename-entries only (not"]
#[doc = " complete paths)."]
pub type notmuch_directory_get_child_directories =
    unsafe extern "C" fn(directory: *mut notmuch_directory_t) -> *mut notmuch_filenames_t;

#[doc = " Delete directory document from the database, and destroy the"]
#[doc = " notmuch_directory_t object. Assumes any child directories and files"]
#[doc = " have been deleted by the caller."]
#[doc = ""]
#[doc = " @since libnotmuch 4.3 (notmuch 0.21)"]
pub type notmuch_directory_delete =
    unsafe extern "C" fn(directory: *mut notmuch_directory_t) -> notmuch_status_t;

#[doc = " Destroy a notmuch_directory_t object."]
pub type notmuch_directory_destroy = unsafe extern "C" fn(directory: *mut notmuch_directory_t);

#[doc = " Is the given 'filenames' iterator pointing at a valid filename."]
#[doc = ""]
#[doc = " When this function returns TRUE, notmuch_filenames_get will return"]
#[doc = " a valid string. Whereas when this function returns FALSE,"]
#[doc = " notmuch_filenames_get will return NULL."]
#[doc = ""]
#[doc = " It is acceptable to pass NULL for 'filenames', in which case this"]
#[doc = " function will always return FALSE."]
pub type notmuch_filenames_valid =
    unsafe extern "C" fn(filenames: *mut notmuch_filenames_t) -> notmuch_bool_t;

#[doc = " Get the current filename from 'filenames' as a string."]
#[doc = ""]
#[doc = " Note: The returned string belongs to 'filenames' and has a lifetime"]
#[doc = " identical to it (and the directory to which it ultimately belongs)."]
#[doc = ""]
#[doc = " It is acceptable to pass NULL for 'filenames', in which case this"]
#[doc = " function will always return NULL."]
pub type notmuch_filenames_get =
    unsafe extern "C" fn(filenames: *mut notmuch_filenames_t) -> *const ::std::os::raw::c_char;

#[doc = " Move the 'filenames' iterator to the next filename."]
#[doc = ""]
#[doc = " If 'filenames' is already pointing at the last filename then the"]
#[doc = " iterator will be moved to a point just beyond that last filename,"]
#[doc = " (where notmuch_filenames_valid will return FALSE and"]
#[doc = " notmuch_filenames_get will return NULL)."]
#[doc = ""]
#[doc = " It is acceptable to pass NULL for 'filenames', in which case this"]
#[doc = " function will do nothing."]
pub type notmuch_filenames_move_to_next = unsafe extern "C" fn(filenames: *mut notmuch_filenames_t);

#[doc = " Destroy a notmuch_filenames_t object."]
#[doc = ""]
#[doc = " It's not strictly necessary to call this function. All memory from"]
#[doc = " the notmuch_filenames_t object will be reclaimed when the"]
#[doc = " containing directory object is destroyed."]
#[doc = ""]
#[doc = " It is acceptable to pass NULL for 'filenames', in which case this"]
#[doc = " function will do nothing."]
pub type notmuch_filenames_destroy = unsafe extern "C" fn(filenames: *mut notmuch_filenames_t);

#[doc = " set config 'key' to 'value'"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_database_set_config = unsafe extern "C" fn(
    db: *mut notmuch_database_t,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " retrieve config item 'key', assign to  'value'"]
#[doc = ""]
#[doc = " keys which have not been previously set with n_d_set_config will"]
#[doc = " return an empty string."]
#[doc = ""]
#[doc = " return value is allocated by malloc and should be freed by the"]
#[doc = " caller."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_database_get_config = unsafe extern "C" fn(
    db: *mut notmuch_database_t,
    key: *const ::std::os::raw::c_char,
    value: *mut *mut ::std::os::raw::c_char,
) -> notmuch_status_t;

#[doc = " Create an iterator for all config items with keys matching a given prefix"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_database_get_config_list = unsafe extern "C" fn(
    db: *mut notmuch_database_t,
    prefix: *const ::std::os::raw::c_char,
    out: *mut *mut notmuch_config_list_t,
) -> notmuch_status_t;

#[doc = " Is 'config_list' iterator valid (i.e. _key, _value, _move_to_next can be called)."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_config_list_valid =
    unsafe extern "C" fn(config_list: *mut notmuch_config_list_t) -> notmuch_bool_t;

#[doc = " return key for current config pair"]
#[doc = ""]
#[doc = " return value is owned by the iterator, and will be destroyed by the"]
#[doc = " next call to notmuch_config_list_key or notmuch_config_list_destroy."]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_config_list_key =
    unsafe extern "C" fn(config_list: *mut notmuch_config_list_t) -> *const ::std::os::raw::c_char;

#[doc = " return 'value' for current config pair"]
#[doc = ""]
#[doc = " return value is owned by the iterator, and will be destroyed by the"]
#[doc = " next call to notmuch_config_list_value or notmuch config_list_destroy"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_config_list_value =
    unsafe extern "C" fn(config_list: *mut notmuch_config_list_t) -> *const ::std::os::raw::c_char;

#[doc = " move 'config_list' iterator to the next pair"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_config_list_move_to_next =
    unsafe extern "C" fn(config_list: *mut notmuch_config_list_t);

#[doc = " free any resources held by 'config_list'"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_config_list_destroy =
    unsafe extern "C" fn(config_list: *mut notmuch_config_list_t);

#[doc = " get the current default indexing options for a given database."]
#[doc = ""]
#[doc = " This object will survive until the database itself is destroyed,"]
#[doc = " but the caller may also release it earlier with"]
#[doc = " notmuch_indexopts_destroy."]
#[doc = ""]
#[doc = " This object represents a set of options on how a message can be"]
#[doc = " added to the index.  At the moment it is a featureless stub."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_database_get_default_indexopts =
    unsafe extern "C" fn(db: *mut notmuch_database_t) -> *mut notmuch_indexopts_t;

pub const notmuch_decryption_policy_t_NOTMUCH_DECRYPT_FALSE: notmuch_decryption_policy_t = 0;
pub const notmuch_decryption_policy_t_NOTMUCH_DECRYPT_TRUE: notmuch_decryption_policy_t = 1;
pub const notmuch_decryption_policy_t_NOTMUCH_DECRYPT_AUTO: notmuch_decryption_policy_t = 2;
pub const notmuch_decryption_policy_t_NOTMUCH_DECRYPT_NOSTASH: notmuch_decryption_policy_t = 3;
#[doc = " Stating a policy about how to decrypt messages."]
#[doc = ""]
#[doc = " See index.decrypt in notmuch-config(1) for more details."]
pub type notmuch_decryption_policy_t = u32;
#[doc = " Specify whether to decrypt encrypted parts while indexing."]
#[doc = ""]
#[doc = " Be aware that the index is likely sufficient to reconstruct the"]
#[doc = " cleartext of the message itself, so please ensure that the notmuch"]
#[doc = " message index is adequately protected. DO NOT SET THIS FLAG TO TRUE"]
#[doc = " without considering the security of your index."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_indexopts_set_decrypt_policy = unsafe extern "C" fn(
    indexopts: *mut notmuch_indexopts_t,
    decrypt_policy: notmuch_decryption_policy_t,
) -> notmuch_status_t;

#[doc = " Return whether to decrypt encrypted parts while indexing."]
#[doc = " see notmuch_indexopts_set_decrypt_policy."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_indexopts_get_decrypt_policy =
    unsafe extern "C" fn(indexopts: *const notmuch_indexopts_t) -> notmuch_decryption_policy_t;

#[doc = " Destroy a notmuch_indexopts_t object."]
#[doc = ""]
#[doc = " @since libnotmuch 5.1 (notmuch 0.26)"]
pub type notmuch_indexopts_destroy = unsafe extern "C" fn(options: *mut notmuch_indexopts_t);

#[doc = " interrogate the library for compile time features"]
#[doc = ""]
#[doc = " @since libnotmuch 4.4 (notmuch 0.23)"]
pub type notmuch_built_with =
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> notmuch_bool_t;

/*
 * melib - gpgme module
 *
 * Copyright 2020 Manos Pitsidianakis
 *
 * This file is part of meli.
 *
 * meli is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * meli is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with meli. If not, see <http://www.gnu.org/licenses/>.
 */

#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(unused)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const GPG_ERROR_H: u32 = 1;
pub const GPGRT_H: u32 = 1;
pub const GPG_ERROR_VERSION: &'static [u8; 5usize] = b"1.35\0";
pub const GPGRT_VERSION: &'static [u8; 5usize] = b"1.35\0";
pub const GPG_ERROR_VERSION_NUMBER: u32 = 74496;
pub const GPGRT_VERSION_NUMBER: u32 = 74496;
pub const GPG_ERR_SYSTEM_ERROR: u32 = 32768;
pub const GPG_ERR_SOURCE_SHIFT: u32 = 24;
pub const GPGRT_HAVE_MACRO_FUNCTION: u32 = 1;
pub const GPG_ERR_INITIALIZED: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const GPGRT_LOG_WITH_PREFIX: u32 = 1;
pub const GPGRT_LOG_WITH_TIME: u32 = 2;
pub const GPGRT_LOG_WITH_PID: u32 = 4;
pub const GPGRT_LOG_RUN_DETACHED: u32 = 256;
pub const GPGRT_LOG_NO_REGISTRY: u32 = 512;
pub const GPGRT_SPAWN_NONBLOCK: u32 = 16;
pub const GPGRT_SPAWN_RUN_ASFW: u32 = 64;
pub const GPGRT_SPAWN_DETACHED: u32 = 128;
pub const GPGME_VERSION: &'static [u8; 7usize] = b"1.12.0\0";
pub const GPGME_VERSION_NUMBER: u32 = 68608;
pub const GPGME_KEYLIST_MODE_LOCAL: u32 = 1;
pub const GPGME_KEYLIST_MODE_EXTERN: u32 = 2;
pub const GPGME_KEYLIST_MODE_SIGS: u32 = 4;
pub const GPGME_KEYLIST_MODE_SIG_NOTATIONS: u32 = 8;
pub const GPGME_KEYLIST_MODE_WITH_SECRET: u32 = 16;
pub const GPGME_KEYLIST_MODE_WITH_TOFU: u32 = 32;
pub const GPGME_KEYLIST_MODE_EPHEMERAL: u32 = 128;
pub const GPGME_KEYLIST_MODE_VALIDATE: u32 = 256;
pub const GPGME_KEYLIST_MODE_LOCATE: u32 = 3;
pub const GPGME_EXPORT_MODE_EXTERN: u32 = 2;
pub const GPGME_EXPORT_MODE_MINIMAL: u32 = 4;
pub const GPGME_EXPORT_MODE_SECRET: u32 = 16;
pub const GPGME_EXPORT_MODE_RAW: u32 = 32;
pub const GPGME_EXPORT_MODE_PKCS12: u32 = 64;
pub const GPGME_EXPORT_MODE_NOUID: u32 = 128;
pub const GPGME_AUDITLOG_DEFAULT: u32 = 0;
pub const GPGME_AUDITLOG_HTML: u32 = 1;
pub const GPGME_AUDITLOG_DIAG: u32 = 2;
pub const GPGME_AUDITLOG_WITH_HELP: u32 = 128;
pub const GPGME_SIG_NOTATION_HUMAN_READABLE: u32 = 1;
pub const GPGME_SIG_NOTATION_CRITICAL: u32 = 2;
pub const GPGME_INCLUDE_CERTS_DEFAULT: i32 = -256;
pub const GPGME_IMPORT_NEW: u32 = 1;
pub const GPGME_IMPORT_UID: u32 = 2;
pub const GPGME_IMPORT_SIG: u32 = 4;
pub const GPGME_IMPORT_SUBKEY: u32 = 8;
pub const GPGME_IMPORT_SECRET: u32 = 16;
pub const GPGME_CREATE_SIGN: u32 = 1;
pub const GPGME_CREATE_ENCR: u32 = 2;
pub const GPGME_CREATE_CERT: u32 = 4;
pub const GPGME_CREATE_AUTH: u32 = 8;
pub const GPGME_CREATE_NOPASSWD: u32 = 128;
pub const GPGME_CREATE_SELFSIGNED: u32 = 256;
pub const GPGME_CREATE_NOSTORE: u32 = 512;
pub const GPGME_CREATE_WANTPUB: u32 = 1024;
pub const GPGME_CREATE_WANTSEC: u32 = 2048;
pub const GPGME_CREATE_FORCE: u32 = 4096;
pub const GPGME_CREATE_NOEXPIRE: u32 = 8192;
pub const GPGME_DELETE_ALLOW_SECRET: u32 = 1;
pub const GPGME_DELETE_FORCE: u32 = 2;
pub const GPGME_KEYSIGN_LOCAL: u32 = 128;
pub const GPGME_KEYSIGN_LFSEP: u32 = 256;
pub const GPGME_KEYSIGN_NOEXPIRE: u32 = 512;
pub const GPGME_INTERACT_CARD: u32 = 1;
pub const GPGME_SPAWN_DETACHED: u32 = 1;
pub const GPGME_SPAWN_ALLOW_SET_FG: u32 = 2;
pub const GPGME_SPAWN_SHOW_WINDOW: u32 = 4;
pub const GPGME_CONF_GROUP: u32 = 1;
pub const GPGME_CONF_OPTIONAL: u32 = 2;
pub const GPGME_CONF_LIST: u32 = 4;
pub const GPGME_CONF_RUNTIME: u32 = 8;
pub const GPGME_CONF_DEFAULT: u32 = 16;
pub const GPGME_CONF_DEFAULT_DESC: u32 = 32;
pub const GPGME_CONF_NO_ARG_DESC: u32 = 64;
pub const GPGME_CONF_NO_CHANGE: u32 = 128;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const gpg_err_source_t_GPG_ERR_SOURCE_UNKNOWN: gpg_err_source_t = 0;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GCRYPT: gpg_err_source_t = 1;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPG: gpg_err_source_t = 2;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGSM: gpg_err_source_t = 3;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGAGENT: gpg_err_source_t = 4;
pub const gpg_err_source_t_GPG_ERR_SOURCE_PINENTRY: gpg_err_source_t = 5;
pub const gpg_err_source_t_GPG_ERR_SOURCE_SCD: gpg_err_source_t = 6;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGME: gpg_err_source_t = 7;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KEYBOX: gpg_err_source_t = 8;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KSBA: gpg_err_source_t = 9;
pub const gpg_err_source_t_GPG_ERR_SOURCE_DIRMNGR: gpg_err_source_t = 10;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GSTI: gpg_err_source_t = 11;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPA: gpg_err_source_t = 12;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KLEO: gpg_err_source_t = 13;
pub const gpg_err_source_t_GPG_ERR_SOURCE_G13: gpg_err_source_t = 14;
pub const gpg_err_source_t_GPG_ERR_SOURCE_ASSUAN: gpg_err_source_t = 15;
pub const gpg_err_source_t_GPG_ERR_SOURCE_TLS: gpg_err_source_t = 17;
pub const gpg_err_source_t_GPG_ERR_SOURCE_ANY: gpg_err_source_t = 31;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_1: gpg_err_source_t = 32;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_2: gpg_err_source_t = 33;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_3: gpg_err_source_t = 34;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_4: gpg_err_source_t = 35;
pub const gpg_err_source_t_GPG_ERR_SOURCE_DIM: gpg_err_source_t = 128;
pub type gpg_err_source_t = u32;
pub const gpg_err_code_t_GPG_ERR_NO_ERROR: gpg_err_code_t = 0;
pub const gpg_err_code_t_GPG_ERR_GENERAL: gpg_err_code_t = 1;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_PACKET: gpg_err_code_t = 2;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_VERSION: gpg_err_code_t = 3;
pub const gpg_err_code_t_GPG_ERR_PUBKEY_ALGO: gpg_err_code_t = 4;
pub const gpg_err_code_t_GPG_ERR_DIGEST_ALGO: gpg_err_code_t = 5;
pub const gpg_err_code_t_GPG_ERR_BAD_PUBKEY: gpg_err_code_t = 6;
pub const gpg_err_code_t_GPG_ERR_BAD_SECKEY: gpg_err_code_t = 7;
pub const gpg_err_code_t_GPG_ERR_BAD_SIGNATURE: gpg_err_code_t = 8;
pub const gpg_err_code_t_GPG_ERR_NO_PUBKEY: gpg_err_code_t = 9;
pub const gpg_err_code_t_GPG_ERR_CHECKSUM: gpg_err_code_t = 10;
pub const gpg_err_code_t_GPG_ERR_BAD_PASSPHRASE: gpg_err_code_t = 11;
pub const gpg_err_code_t_GPG_ERR_CIPHER_ALGO: gpg_err_code_t = 12;
pub const gpg_err_code_t_GPG_ERR_KEYRING_OPEN: gpg_err_code_t = 13;
pub const gpg_err_code_t_GPG_ERR_INV_PACKET: gpg_err_code_t = 14;
pub const gpg_err_code_t_GPG_ERR_INV_ARMOR: gpg_err_code_t = 15;
pub const gpg_err_code_t_GPG_ERR_NO_USER_ID: gpg_err_code_t = 16;
pub const gpg_err_code_t_GPG_ERR_NO_SECKEY: gpg_err_code_t = 17;
pub const gpg_err_code_t_GPG_ERR_WRONG_SECKEY: gpg_err_code_t = 18;
pub const gpg_err_code_t_GPG_ERR_BAD_KEY: gpg_err_code_t = 19;
pub const gpg_err_code_t_GPG_ERR_COMPR_ALGO: gpg_err_code_t = 20;
pub const gpg_err_code_t_GPG_ERR_NO_PRIME: gpg_err_code_t = 21;
pub const gpg_err_code_t_GPG_ERR_NO_ENCODING_METHOD: gpg_err_code_t = 22;
pub const gpg_err_code_t_GPG_ERR_NO_ENCRYPTION_SCHEME: gpg_err_code_t = 23;
pub const gpg_err_code_t_GPG_ERR_NO_SIGNATURE_SCHEME: gpg_err_code_t = 24;
pub const gpg_err_code_t_GPG_ERR_INV_ATTR: gpg_err_code_t = 25;
pub const gpg_err_code_t_GPG_ERR_NO_VALUE: gpg_err_code_t = 26;
pub const gpg_err_code_t_GPG_ERR_NOT_FOUND: gpg_err_code_t = 27;
pub const gpg_err_code_t_GPG_ERR_VALUE_NOT_FOUND: gpg_err_code_t = 28;
pub const gpg_err_code_t_GPG_ERR_SYNTAX: gpg_err_code_t = 29;
pub const gpg_err_code_t_GPG_ERR_BAD_MPI: gpg_err_code_t = 30;
pub const gpg_err_code_t_GPG_ERR_INV_PASSPHRASE: gpg_err_code_t = 31;
pub const gpg_err_code_t_GPG_ERR_SIG_CLASS: gpg_err_code_t = 32;
pub const gpg_err_code_t_GPG_ERR_RESOURCE_LIMIT: gpg_err_code_t = 33;
pub const gpg_err_code_t_GPG_ERR_INV_KEYRING: gpg_err_code_t = 34;
pub const gpg_err_code_t_GPG_ERR_TRUSTDB: gpg_err_code_t = 35;
pub const gpg_err_code_t_GPG_ERR_BAD_CERT: gpg_err_code_t = 36;
pub const gpg_err_code_t_GPG_ERR_INV_USER_ID: gpg_err_code_t = 37;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED: gpg_err_code_t = 38;
pub const gpg_err_code_t_GPG_ERR_TIME_CONFLICT: gpg_err_code_t = 39;
pub const gpg_err_code_t_GPG_ERR_KEYSERVER: gpg_err_code_t = 40;
pub const gpg_err_code_t_GPG_ERR_WRONG_PUBKEY_ALGO: gpg_err_code_t = 41;
pub const gpg_err_code_t_GPG_ERR_TRIBUTE_TO_D_A: gpg_err_code_t = 42;
pub const gpg_err_code_t_GPG_ERR_WEAK_KEY: gpg_err_code_t = 43;
pub const gpg_err_code_t_GPG_ERR_INV_KEYLEN: gpg_err_code_t = 44;
pub const gpg_err_code_t_GPG_ERR_INV_ARG: gpg_err_code_t = 45;
pub const gpg_err_code_t_GPG_ERR_BAD_URI: gpg_err_code_t = 46;
pub const gpg_err_code_t_GPG_ERR_INV_URI: gpg_err_code_t = 47;
pub const gpg_err_code_t_GPG_ERR_NETWORK: gpg_err_code_t = 48;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_HOST: gpg_err_code_t = 49;
pub const gpg_err_code_t_GPG_ERR_SELFTEST_FAILED: gpg_err_code_t = 50;
pub const gpg_err_code_t_GPG_ERR_NOT_ENCRYPTED: gpg_err_code_t = 51;
pub const gpg_err_code_t_GPG_ERR_NOT_PROCESSED: gpg_err_code_t = 52;
pub const gpg_err_code_t_GPG_ERR_UNUSABLE_PUBKEY: gpg_err_code_t = 53;
pub const gpg_err_code_t_GPG_ERR_UNUSABLE_SECKEY: gpg_err_code_t = 54;
pub const gpg_err_code_t_GPG_ERR_INV_VALUE: gpg_err_code_t = 55;
pub const gpg_err_code_t_GPG_ERR_BAD_CERT_CHAIN: gpg_err_code_t = 56;
pub const gpg_err_code_t_GPG_ERR_MISSING_CERT: gpg_err_code_t = 57;
pub const gpg_err_code_t_GPG_ERR_NO_DATA: gpg_err_code_t = 58;
pub const gpg_err_code_t_GPG_ERR_BUG: gpg_err_code_t = 59;
pub const gpg_err_code_t_GPG_ERR_NOT_SUPPORTED: gpg_err_code_t = 60;
pub const gpg_err_code_t_GPG_ERR_INV_OP: gpg_err_code_t = 61;
pub const gpg_err_code_t_GPG_ERR_TIMEOUT: gpg_err_code_t = 62;
pub const gpg_err_code_t_GPG_ERR_INTERNAL: gpg_err_code_t = 63;
pub const gpg_err_code_t_GPG_ERR_EOF_GCRYPT: gpg_err_code_t = 64;
pub const gpg_err_code_t_GPG_ERR_INV_OBJ: gpg_err_code_t = 65;
pub const gpg_err_code_t_GPG_ERR_TOO_SHORT: gpg_err_code_t = 66;
pub const gpg_err_code_t_GPG_ERR_TOO_LARGE: gpg_err_code_t = 67;
pub const gpg_err_code_t_GPG_ERR_NO_OBJ: gpg_err_code_t = 68;
pub const gpg_err_code_t_GPG_ERR_NOT_IMPLEMENTED: gpg_err_code_t = 69;
pub const gpg_err_code_t_GPG_ERR_CONFLICT: gpg_err_code_t = 70;
pub const gpg_err_code_t_GPG_ERR_INV_CIPHER_MODE: gpg_err_code_t = 71;
pub const gpg_err_code_t_GPG_ERR_INV_FLAG: gpg_err_code_t = 72;
pub const gpg_err_code_t_GPG_ERR_INV_HANDLE: gpg_err_code_t = 73;
pub const gpg_err_code_t_GPG_ERR_TRUNCATED: gpg_err_code_t = 74;
pub const gpg_err_code_t_GPG_ERR_INCOMPLETE_LINE: gpg_err_code_t = 75;
pub const gpg_err_code_t_GPG_ERR_INV_RESPONSE: gpg_err_code_t = 76;
pub const gpg_err_code_t_GPG_ERR_NO_AGENT: gpg_err_code_t = 77;
pub const gpg_err_code_t_GPG_ERR_AGENT: gpg_err_code_t = 78;
pub const gpg_err_code_t_GPG_ERR_INV_DATA: gpg_err_code_t = 79;
pub const gpg_err_code_t_GPG_ERR_ASSUAN_SERVER_FAULT: gpg_err_code_t = 80;
pub const gpg_err_code_t_GPG_ERR_ASSUAN: gpg_err_code_t = 81;
pub const gpg_err_code_t_GPG_ERR_INV_SESSION_KEY: gpg_err_code_t = 82;
pub const gpg_err_code_t_GPG_ERR_INV_SEXP: gpg_err_code_t = 83;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_ALGORITHM: gpg_err_code_t = 84;
pub const gpg_err_code_t_GPG_ERR_NO_PIN_ENTRY: gpg_err_code_t = 85;
pub const gpg_err_code_t_GPG_ERR_PIN_ENTRY: gpg_err_code_t = 86;
pub const gpg_err_code_t_GPG_ERR_BAD_PIN: gpg_err_code_t = 87;
pub const gpg_err_code_t_GPG_ERR_INV_NAME: gpg_err_code_t = 88;
pub const gpg_err_code_t_GPG_ERR_BAD_DATA: gpg_err_code_t = 89;
pub const gpg_err_code_t_GPG_ERR_INV_PARAMETER: gpg_err_code_t = 90;
pub const gpg_err_code_t_GPG_ERR_WRONG_CARD: gpg_err_code_t = 91;
pub const gpg_err_code_t_GPG_ERR_NO_DIRMNGR: gpg_err_code_t = 92;
pub const gpg_err_code_t_GPG_ERR_DIRMNGR: gpg_err_code_t = 93;
pub const gpg_err_code_t_GPG_ERR_CERT_REVOKED: gpg_err_code_t = 94;
pub const gpg_err_code_t_GPG_ERR_NO_CRL_KNOWN: gpg_err_code_t = 95;
pub const gpg_err_code_t_GPG_ERR_CRL_TOO_OLD: gpg_err_code_t = 96;
pub const gpg_err_code_t_GPG_ERR_LINE_TOO_LONG: gpg_err_code_t = 97;
pub const gpg_err_code_t_GPG_ERR_NOT_TRUSTED: gpg_err_code_t = 98;
pub const gpg_err_code_t_GPG_ERR_CANCELED: gpg_err_code_t = 99;
pub const gpg_err_code_t_GPG_ERR_BAD_CA_CERT: gpg_err_code_t = 100;
pub const gpg_err_code_t_GPG_ERR_CERT_EXPIRED: gpg_err_code_t = 101;
pub const gpg_err_code_t_GPG_ERR_CERT_TOO_YOUNG: gpg_err_code_t = 102;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CERT: gpg_err_code_t = 103;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_SEXP: gpg_err_code_t = 104;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_PROTECTION: gpg_err_code_t = 105;
pub const gpg_err_code_t_GPG_ERR_CORRUPTED_PROTECTION: gpg_err_code_t = 106;
pub const gpg_err_code_t_GPG_ERR_AMBIGUOUS_NAME: gpg_err_code_t = 107;
pub const gpg_err_code_t_GPG_ERR_CARD: gpg_err_code_t = 108;
pub const gpg_err_code_t_GPG_ERR_CARD_RESET: gpg_err_code_t = 109;
pub const gpg_err_code_t_GPG_ERR_CARD_REMOVED: gpg_err_code_t = 110;
pub const gpg_err_code_t_GPG_ERR_INV_CARD: gpg_err_code_t = 111;
pub const gpg_err_code_t_GPG_ERR_CARD_NOT_PRESENT: gpg_err_code_t = 112;
pub const gpg_err_code_t_GPG_ERR_NO_PKCS15_APP: gpg_err_code_t = 113;
pub const gpg_err_code_t_GPG_ERR_NOT_CONFIRMED: gpg_err_code_t = 114;
pub const gpg_err_code_t_GPG_ERR_CONFIGURATION: gpg_err_code_t = 115;
pub const gpg_err_code_t_GPG_ERR_NO_POLICY_MATCH: gpg_err_code_t = 116;
pub const gpg_err_code_t_GPG_ERR_INV_INDEX: gpg_err_code_t = 117;
pub const gpg_err_code_t_GPG_ERR_INV_ID: gpg_err_code_t = 118;
pub const gpg_err_code_t_GPG_ERR_NO_SCDAEMON: gpg_err_code_t = 119;
pub const gpg_err_code_t_GPG_ERR_SCDAEMON: gpg_err_code_t = 120;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_PROTOCOL: gpg_err_code_t = 121;
pub const gpg_err_code_t_GPG_ERR_BAD_PIN_METHOD: gpg_err_code_t = 122;
pub const gpg_err_code_t_GPG_ERR_CARD_NOT_INITIALIZED: gpg_err_code_t = 123;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_OPERATION: gpg_err_code_t = 124;
pub const gpg_err_code_t_GPG_ERR_WRONG_KEY_USAGE: gpg_err_code_t = 125;
pub const gpg_err_code_t_GPG_ERR_NOTHING_FOUND: gpg_err_code_t = 126;
pub const gpg_err_code_t_GPG_ERR_WRONG_BLOB_TYPE: gpg_err_code_t = 127;
pub const gpg_err_code_t_GPG_ERR_MISSING_VALUE: gpg_err_code_t = 128;
pub const gpg_err_code_t_GPG_ERR_HARDWARE: gpg_err_code_t = 129;
pub const gpg_err_code_t_GPG_ERR_PIN_BLOCKED: gpg_err_code_t = 130;
pub const gpg_err_code_t_GPG_ERR_USE_CONDITIONS: gpg_err_code_t = 131;
pub const gpg_err_code_t_GPG_ERR_PIN_NOT_SYNCED: gpg_err_code_t = 132;
pub const gpg_err_code_t_GPG_ERR_INV_CRL: gpg_err_code_t = 133;
pub const gpg_err_code_t_GPG_ERR_BAD_BER: gpg_err_code_t = 134;
pub const gpg_err_code_t_GPG_ERR_INV_BER: gpg_err_code_t = 135;
pub const gpg_err_code_t_GPG_ERR_ELEMENT_NOT_FOUND: gpg_err_code_t = 136;
pub const gpg_err_code_t_GPG_ERR_IDENTIFIER_NOT_FOUND: gpg_err_code_t = 137;
pub const gpg_err_code_t_GPG_ERR_INV_TAG: gpg_err_code_t = 138;
pub const gpg_err_code_t_GPG_ERR_INV_LENGTH: gpg_err_code_t = 139;
pub const gpg_err_code_t_GPG_ERR_INV_KEYINFO: gpg_err_code_t = 140;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED_TAG: gpg_err_code_t = 141;
pub const gpg_err_code_t_GPG_ERR_NOT_DER_ENCODED: gpg_err_code_t = 142;
pub const gpg_err_code_t_GPG_ERR_NO_CMS_OBJ: gpg_err_code_t = 143;
pub const gpg_err_code_t_GPG_ERR_INV_CMS_OBJ: gpg_err_code_t = 144;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CMS_OBJ: gpg_err_code_t = 145;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CMS_OBJ: gpg_err_code_t = 146;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_ENCODING: gpg_err_code_t = 147;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CMS_VERSION: gpg_err_code_t = 148;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_ALGORITHM: gpg_err_code_t = 149;
pub const gpg_err_code_t_GPG_ERR_INV_ENGINE: gpg_err_code_t = 150;
pub const gpg_err_code_t_GPG_ERR_PUBKEY_NOT_TRUSTED: gpg_err_code_t = 151;
pub const gpg_err_code_t_GPG_ERR_DECRYPT_FAILED: gpg_err_code_t = 152;
pub const gpg_err_code_t_GPG_ERR_KEY_EXPIRED: gpg_err_code_t = 153;
pub const gpg_err_code_t_GPG_ERR_SIG_EXPIRED: gpg_err_code_t = 154;
pub const gpg_err_code_t_GPG_ERR_ENCODING_PROBLEM: gpg_err_code_t = 155;
pub const gpg_err_code_t_GPG_ERR_INV_STATE: gpg_err_code_t = 156;
pub const gpg_err_code_t_GPG_ERR_DUP_VALUE: gpg_err_code_t = 157;
pub const gpg_err_code_t_GPG_ERR_MISSING_ACTION: gpg_err_code_t = 158;
pub const gpg_err_code_t_GPG_ERR_MODULE_NOT_FOUND: gpg_err_code_t = 159;
pub const gpg_err_code_t_GPG_ERR_INV_OID_STRING: gpg_err_code_t = 160;
pub const gpg_err_code_t_GPG_ERR_INV_TIME: gpg_err_code_t = 161;
pub const gpg_err_code_t_GPG_ERR_INV_CRL_OBJ: gpg_err_code_t = 162;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CRL_VERSION: gpg_err_code_t = 163;
pub const gpg_err_code_t_GPG_ERR_INV_CERT_OBJ: gpg_err_code_t = 164;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_NAME: gpg_err_code_t = 165;
pub const gpg_err_code_t_GPG_ERR_LOCALE_PROBLEM: gpg_err_code_t = 166;
pub const gpg_err_code_t_GPG_ERR_NOT_LOCKED: gpg_err_code_t = 167;
pub const gpg_err_code_t_GPG_ERR_PROTOCOL_VIOLATION: gpg_err_code_t = 168;
pub const gpg_err_code_t_GPG_ERR_INV_MAC: gpg_err_code_t = 169;
pub const gpg_err_code_t_GPG_ERR_INV_REQUEST: gpg_err_code_t = 170;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_EXTN: gpg_err_code_t = 171;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CRIT_EXTN: gpg_err_code_t = 172;
pub const gpg_err_code_t_GPG_ERR_LOCKED: gpg_err_code_t = 173;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_OPTION: gpg_err_code_t = 174;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_COMMAND: gpg_err_code_t = 175;
pub const gpg_err_code_t_GPG_ERR_NOT_OPERATIONAL: gpg_err_code_t = 176;
pub const gpg_err_code_t_GPG_ERR_NO_PASSPHRASE: gpg_err_code_t = 177;
pub const gpg_err_code_t_GPG_ERR_NO_PIN: gpg_err_code_t = 178;
pub const gpg_err_code_t_GPG_ERR_NOT_ENABLED: gpg_err_code_t = 179;
pub const gpg_err_code_t_GPG_ERR_NO_ENGINE: gpg_err_code_t = 180;
pub const gpg_err_code_t_GPG_ERR_MISSING_KEY: gpg_err_code_t = 181;
pub const gpg_err_code_t_GPG_ERR_TOO_MANY: gpg_err_code_t = 182;
pub const gpg_err_code_t_GPG_ERR_LIMIT_REACHED: gpg_err_code_t = 183;
pub const gpg_err_code_t_GPG_ERR_NOT_INITIALIZED: gpg_err_code_t = 184;
pub const gpg_err_code_t_GPG_ERR_MISSING_ISSUER_CERT: gpg_err_code_t = 185;
pub const gpg_err_code_t_GPG_ERR_NO_KEYSERVER: gpg_err_code_t = 186;
pub const gpg_err_code_t_GPG_ERR_INV_CURVE: gpg_err_code_t = 187;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CURVE: gpg_err_code_t = 188;
pub const gpg_err_code_t_GPG_ERR_DUP_KEY: gpg_err_code_t = 189;
pub const gpg_err_code_t_GPG_ERR_AMBIGUOUS: gpg_err_code_t = 190;
pub const gpg_err_code_t_GPG_ERR_NO_CRYPT_CTX: gpg_err_code_t = 191;
pub const gpg_err_code_t_GPG_ERR_WRONG_CRYPT_CTX: gpg_err_code_t = 192;
pub const gpg_err_code_t_GPG_ERR_BAD_CRYPT_CTX: gpg_err_code_t = 193;
pub const gpg_err_code_t_GPG_ERR_CRYPT_CTX_CONFLICT: gpg_err_code_t = 194;
pub const gpg_err_code_t_GPG_ERR_BROKEN_PUBKEY: gpg_err_code_t = 195;
pub const gpg_err_code_t_GPG_ERR_BROKEN_SECKEY: gpg_err_code_t = 196;
pub const gpg_err_code_t_GPG_ERR_MAC_ALGO: gpg_err_code_t = 197;
pub const gpg_err_code_t_GPG_ERR_FULLY_CANCELED: gpg_err_code_t = 198;
pub const gpg_err_code_t_GPG_ERR_UNFINISHED: gpg_err_code_t = 199;
pub const gpg_err_code_t_GPG_ERR_BUFFER_TOO_SHORT: gpg_err_code_t = 200;
pub const gpg_err_code_t_GPG_ERR_SEXP_INV_LEN_SPEC: gpg_err_code_t = 201;
pub const gpg_err_code_t_GPG_ERR_SEXP_STRING_TOO_LONG: gpg_err_code_t = 202;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNMATCHED_PAREN: gpg_err_code_t = 203;
pub const gpg_err_code_t_GPG_ERR_SEXP_NOT_CANONICAL: gpg_err_code_t = 204;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_CHARACTER: gpg_err_code_t = 205;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_QUOTATION: gpg_err_code_t = 206;
pub const gpg_err_code_t_GPG_ERR_SEXP_ZERO_PREFIX: gpg_err_code_t = 207;
pub const gpg_err_code_t_GPG_ERR_SEXP_NESTED_DH: gpg_err_code_t = 208;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNMATCHED_DH: gpg_err_code_t = 209;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNEXPECTED_PUNC: gpg_err_code_t = 210;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_HEX_CHAR: gpg_err_code_t = 211;
pub const gpg_err_code_t_GPG_ERR_SEXP_ODD_HEX_NUMBERS: gpg_err_code_t = 212;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_OCT_CHAR: gpg_err_code_t = 213;
pub const gpg_err_code_t_GPG_ERR_SUBKEYS_EXP_OR_REV: gpg_err_code_t = 217;
pub const gpg_err_code_t_GPG_ERR_DB_CORRUPTED: gpg_err_code_t = 218;
pub const gpg_err_code_t_GPG_ERR_SERVER_FAILED: gpg_err_code_t = 219;
pub const gpg_err_code_t_GPG_ERR_NO_NAME: gpg_err_code_t = 220;
pub const gpg_err_code_t_GPG_ERR_NO_KEY: gpg_err_code_t = 221;
pub const gpg_err_code_t_GPG_ERR_LEGACY_KEY: gpg_err_code_t = 222;
pub const gpg_err_code_t_GPG_ERR_REQUEST_TOO_SHORT: gpg_err_code_t = 223;
pub const gpg_err_code_t_GPG_ERR_REQUEST_TOO_LONG: gpg_err_code_t = 224;
pub const gpg_err_code_t_GPG_ERR_OBJ_TERM_STATE: gpg_err_code_t = 225;
pub const gpg_err_code_t_GPG_ERR_NO_CERT_CHAIN: gpg_err_code_t = 226;
pub const gpg_err_code_t_GPG_ERR_CERT_TOO_LARGE: gpg_err_code_t = 227;
pub const gpg_err_code_t_GPG_ERR_INV_RECORD: gpg_err_code_t = 228;
pub const gpg_err_code_t_GPG_ERR_BAD_MAC: gpg_err_code_t = 229;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED_MSG: gpg_err_code_t = 230;
pub const gpg_err_code_t_GPG_ERR_COMPR_FAILED: gpg_err_code_t = 231;
pub const gpg_err_code_t_GPG_ERR_WOULD_WRAP: gpg_err_code_t = 232;
pub const gpg_err_code_t_GPG_ERR_FATAL_ALERT: gpg_err_code_t = 233;
pub const gpg_err_code_t_GPG_ERR_NO_CIPHER: gpg_err_code_t = 234;
pub const gpg_err_code_t_GPG_ERR_MISSING_CLIENT_CERT: gpg_err_code_t = 235;
pub const gpg_err_code_t_GPG_ERR_CLOSE_NOTIFY: gpg_err_code_t = 236;
pub const gpg_err_code_t_GPG_ERR_TICKET_EXPIRED: gpg_err_code_t = 237;
pub const gpg_err_code_t_GPG_ERR_BAD_TICKET: gpg_err_code_t = 238;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_IDENTITY: gpg_err_code_t = 239;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT: gpg_err_code_t = 240;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT_REQ: gpg_err_code_t = 241;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT_VER: gpg_err_code_t = 242;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CHANGE_CIPHER: gpg_err_code_t = 243;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CLIENT_HELLO: gpg_err_code_t = 244;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_HELLO: gpg_err_code_t = 245;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_HELLO_DONE: gpg_err_code_t = 246;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_FINISHED: gpg_err_code_t = 247;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_KEX: gpg_err_code_t = 248;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CLIENT_KEX: gpg_err_code_t = 249;
pub const gpg_err_code_t_GPG_ERR_BOGUS_STRING: gpg_err_code_t = 250;
pub const gpg_err_code_t_GPG_ERR_FORBIDDEN: gpg_err_code_t = 251;
pub const gpg_err_code_t_GPG_ERR_KEY_DISABLED: gpg_err_code_t = 252;
pub const gpg_err_code_t_GPG_ERR_KEY_ON_CARD: gpg_err_code_t = 253;
pub const gpg_err_code_t_GPG_ERR_INV_LOCK_OBJ: gpg_err_code_t = 254;
pub const gpg_err_code_t_GPG_ERR_TRUE: gpg_err_code_t = 255;
pub const gpg_err_code_t_GPG_ERR_FALSE: gpg_err_code_t = 256;
pub const gpg_err_code_t_GPG_ERR_ASS_GENERAL: gpg_err_code_t = 257;
pub const gpg_err_code_t_GPG_ERR_ASS_ACCEPT_FAILED: gpg_err_code_t = 258;
pub const gpg_err_code_t_GPG_ERR_ASS_CONNECT_FAILED: gpg_err_code_t = 259;
pub const gpg_err_code_t_GPG_ERR_ASS_INV_RESPONSE: gpg_err_code_t = 260;
pub const gpg_err_code_t_GPG_ERR_ASS_INV_VALUE: gpg_err_code_t = 261;
pub const gpg_err_code_t_GPG_ERR_ASS_INCOMPLETE_LINE: gpg_err_code_t = 262;
pub const gpg_err_code_t_GPG_ERR_ASS_LINE_TOO_LONG: gpg_err_code_t = 263;
pub const gpg_err_code_t_GPG_ERR_ASS_NESTED_COMMANDS: gpg_err_code_t = 264;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_DATA_CB: gpg_err_code_t = 265;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_INQUIRE_CB: gpg_err_code_t = 266;
pub const gpg_err_code_t_GPG_ERR_ASS_NOT_A_SERVER: gpg_err_code_t = 267;
pub const gpg_err_code_t_GPG_ERR_ASS_NOT_A_CLIENT: gpg_err_code_t = 268;
pub const gpg_err_code_t_GPG_ERR_ASS_SERVER_START: gpg_err_code_t = 269;
pub const gpg_err_code_t_GPG_ERR_ASS_READ_ERROR: gpg_err_code_t = 270;
pub const gpg_err_code_t_GPG_ERR_ASS_WRITE_ERROR: gpg_err_code_t = 271;
pub const gpg_err_code_t_GPG_ERR_ASS_TOO_MUCH_DATA: gpg_err_code_t = 273;
pub const gpg_err_code_t_GPG_ERR_ASS_UNEXPECTED_CMD: gpg_err_code_t = 274;
pub const gpg_err_code_t_GPG_ERR_ASS_UNKNOWN_CMD: gpg_err_code_t = 275;
pub const gpg_err_code_t_GPG_ERR_ASS_SYNTAX: gpg_err_code_t = 276;
pub const gpg_err_code_t_GPG_ERR_ASS_CANCELED: gpg_err_code_t = 277;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_INPUT: gpg_err_code_t = 278;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_OUTPUT: gpg_err_code_t = 279;
pub const gpg_err_code_t_GPG_ERR_ASS_PARAMETER: gpg_err_code_t = 280;
pub const gpg_err_code_t_GPG_ERR_ASS_UNKNOWN_INQUIRE: gpg_err_code_t = 281;
pub const gpg_err_code_t_GPG_ERR_ENGINE_TOO_OLD: gpg_err_code_t = 300;
pub const gpg_err_code_t_GPG_ERR_WINDOW_TOO_SMALL: gpg_err_code_t = 301;
pub const gpg_err_code_t_GPG_ERR_WINDOW_TOO_LARGE: gpg_err_code_t = 302;
pub const gpg_err_code_t_GPG_ERR_MISSING_ENVVAR: gpg_err_code_t = 303;
pub const gpg_err_code_t_GPG_ERR_USER_ID_EXISTS: gpg_err_code_t = 304;
pub const gpg_err_code_t_GPG_ERR_NAME_EXISTS: gpg_err_code_t = 305;
pub const gpg_err_code_t_GPG_ERR_DUP_NAME: gpg_err_code_t = 306;
pub const gpg_err_code_t_GPG_ERR_TOO_YOUNG: gpg_err_code_t = 307;
pub const gpg_err_code_t_GPG_ERR_TOO_OLD: gpg_err_code_t = 308;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_FLAG: gpg_err_code_t = 309;
pub const gpg_err_code_t_GPG_ERR_INV_ORDER: gpg_err_code_t = 310;
pub const gpg_err_code_t_GPG_ERR_ALREADY_FETCHED: gpg_err_code_t = 311;
pub const gpg_err_code_t_GPG_ERR_TRY_LATER: gpg_err_code_t = 312;
pub const gpg_err_code_t_GPG_ERR_WRONG_NAME: gpg_err_code_t = 313;
pub const gpg_err_code_t_GPG_ERR_SYSTEM_BUG: gpg_err_code_t = 666;
pub const gpg_err_code_t_GPG_ERR_DNS_UNKNOWN: gpg_err_code_t = 711;
pub const gpg_err_code_t_GPG_ERR_DNS_SECTION: gpg_err_code_t = 712;
pub const gpg_err_code_t_GPG_ERR_DNS_ADDRESS: gpg_err_code_t = 713;
pub const gpg_err_code_t_GPG_ERR_DNS_NO_QUERY: gpg_err_code_t = 714;
pub const gpg_err_code_t_GPG_ERR_DNS_NO_ANSWER: gpg_err_code_t = 715;
pub const gpg_err_code_t_GPG_ERR_DNS_CLOSED: gpg_err_code_t = 716;
pub const gpg_err_code_t_GPG_ERR_DNS_VERIFY: gpg_err_code_t = 717;
pub const gpg_err_code_t_GPG_ERR_DNS_TIMEOUT: gpg_err_code_t = 718;
pub const gpg_err_code_t_GPG_ERR_LDAP_GENERAL: gpg_err_code_t = 721;
pub const gpg_err_code_t_GPG_ERR_LDAP_ATTR_GENERAL: gpg_err_code_t = 722;
pub const gpg_err_code_t_GPG_ERR_LDAP_NAME_GENERAL: gpg_err_code_t = 723;
pub const gpg_err_code_t_GPG_ERR_LDAP_SECURITY_GENERAL: gpg_err_code_t = 724;
pub const gpg_err_code_t_GPG_ERR_LDAP_SERVICE_GENERAL: gpg_err_code_t = 725;
pub const gpg_err_code_t_GPG_ERR_LDAP_UPDATE_GENERAL: gpg_err_code_t = 726;
pub const gpg_err_code_t_GPG_ERR_LDAP_E_GENERAL: gpg_err_code_t = 727;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_GENERAL: gpg_err_code_t = 728;
pub const gpg_err_code_t_GPG_ERR_LDAP_OTHER_GENERAL: gpg_err_code_t = 729;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_CONNECTING: gpg_err_code_t = 750;
pub const gpg_err_code_t_GPG_ERR_LDAP_REFERRAL_LIMIT: gpg_err_code_t = 751;
pub const gpg_err_code_t_GPG_ERR_LDAP_CLIENT_LOOP: gpg_err_code_t = 752;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_RESULTS: gpg_err_code_t = 754;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONTROL_NOT_FOUND: gpg_err_code_t = 755;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_SUPPORTED: gpg_err_code_t = 756;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONNECT: gpg_err_code_t = 757;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_MEMORY: gpg_err_code_t = 758;
pub const gpg_err_code_t_GPG_ERR_LDAP_PARAM: gpg_err_code_t = 759;
pub const gpg_err_code_t_GPG_ERR_LDAP_USER_CANCELLED: gpg_err_code_t = 760;
pub const gpg_err_code_t_GPG_ERR_LDAP_FILTER: gpg_err_code_t = 761;
pub const gpg_err_code_t_GPG_ERR_LDAP_AUTH_UNKNOWN: gpg_err_code_t = 762;
pub const gpg_err_code_t_GPG_ERR_LDAP_TIMEOUT: gpg_err_code_t = 763;
pub const gpg_err_code_t_GPG_ERR_LDAP_DECODING: gpg_err_code_t = 764;
pub const gpg_err_code_t_GPG_ERR_LDAP_ENCODING: gpg_err_code_t = 765;
pub const gpg_err_code_t_GPG_ERR_LDAP_LOCAL: gpg_err_code_t = 766;
pub const gpg_err_code_t_GPG_ERR_LDAP_SERVER_DOWN: gpg_err_code_t = 767;
pub const gpg_err_code_t_GPG_ERR_LDAP_SUCCESS: gpg_err_code_t = 768;
pub const gpg_err_code_t_GPG_ERR_LDAP_OPERATIONS: gpg_err_code_t = 769;
pub const gpg_err_code_t_GPG_ERR_LDAP_PROTOCOL: gpg_err_code_t = 770;
pub const gpg_err_code_t_GPG_ERR_LDAP_TIMELIMIT: gpg_err_code_t = 771;
pub const gpg_err_code_t_GPG_ERR_LDAP_SIZELIMIT: gpg_err_code_t = 772;
pub const gpg_err_code_t_GPG_ERR_LDAP_COMPARE_FALSE: gpg_err_code_t = 773;
pub const gpg_err_code_t_GPG_ERR_LDAP_COMPARE_TRUE: gpg_err_code_t = 774;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNSUPPORTED_AUTH: gpg_err_code_t = 775;
pub const gpg_err_code_t_GPG_ERR_LDAP_STRONG_AUTH_RQRD: gpg_err_code_t = 776;
pub const gpg_err_code_t_GPG_ERR_LDAP_PARTIAL_RESULTS: gpg_err_code_t = 777;
pub const gpg_err_code_t_GPG_ERR_LDAP_REFERRAL: gpg_err_code_t = 778;
pub const gpg_err_code_t_GPG_ERR_LDAP_ADMINLIMIT: gpg_err_code_t = 779;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN: gpg_err_code_t = 780;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONFIDENT_RQRD: gpg_err_code_t = 781;
pub const gpg_err_code_t_GPG_ERR_LDAP_SASL_BIND_INPROG: gpg_err_code_t = 782;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE: gpg_err_code_t = 784;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNDEFINED_TYPE: gpg_err_code_t = 785;
pub const gpg_err_code_t_GPG_ERR_LDAP_BAD_MATCHING: gpg_err_code_t = 786;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONST_VIOLATION: gpg_err_code_t = 787;
pub const gpg_err_code_t_GPG_ERR_LDAP_TYPE_VALUE_EXISTS: gpg_err_code_t = 788;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_SYNTAX: gpg_err_code_t = 789;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_OBJ: gpg_err_code_t = 800;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALIAS_PROBLEM: gpg_err_code_t = 801;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_DN_SYNTAX: gpg_err_code_t = 802;
pub const gpg_err_code_t_GPG_ERR_LDAP_IS_LEAF: gpg_err_code_t = 803;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALIAS_DEREF: gpg_err_code_t = 804;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_PROXY_AUTH_FAIL: gpg_err_code_t = 815;
pub const gpg_err_code_t_GPG_ERR_LDAP_BAD_AUTH: gpg_err_code_t = 816;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_CREDENTIALS: gpg_err_code_t = 817;
pub const gpg_err_code_t_GPG_ERR_LDAP_INSUFFICIENT_ACC: gpg_err_code_t = 818;
pub const gpg_err_code_t_GPG_ERR_LDAP_BUSY: gpg_err_code_t = 819;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNAVAILABLE: gpg_err_code_t = 820;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNWILL_TO_PERFORM: gpg_err_code_t = 821;
pub const gpg_err_code_t_GPG_ERR_LDAP_LOOP_DETECT: gpg_err_code_t = 822;
pub const gpg_err_code_t_GPG_ERR_LDAP_NAMING_VIOLATION: gpg_err_code_t = 832;
pub const gpg_err_code_t_GPG_ERR_LDAP_OBJ_CLS_VIOLATION: gpg_err_code_t = 833;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_ALLOW_NONLEAF: gpg_err_code_t = 834;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_ALLOW_ON_RDN: gpg_err_code_t = 835;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALREADY_EXISTS: gpg_err_code_t = 836;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_OBJ_CLASS_MODS: gpg_err_code_t = 837;
pub const gpg_err_code_t_GPG_ERR_LDAP_RESULTS_TOO_LARGE: gpg_err_code_t = 838;
pub const gpg_err_code_t_GPG_ERR_LDAP_AFFECTS_MULT_DSAS: gpg_err_code_t = 839;
pub const gpg_err_code_t_GPG_ERR_LDAP_VLV: gpg_err_code_t = 844;
pub const gpg_err_code_t_GPG_ERR_LDAP_OTHER: gpg_err_code_t = 848;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_RESOURCE_LIMIT: gpg_err_code_t = 881;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_SEC_VIOLATION: gpg_err_code_t = 882;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_INV_DATA: gpg_err_code_t = 883;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_UNSUP_SCHEME: gpg_err_code_t = 884;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_RELOAD: gpg_err_code_t = 885;
pub const gpg_err_code_t_GPG_ERR_LDAP_CANCELLED: gpg_err_code_t = 886;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_OPERATION: gpg_err_code_t = 887;
pub const gpg_err_code_t_GPG_ERR_LDAP_TOO_LATE: gpg_err_code_t = 888;
pub const gpg_err_code_t_GPG_ERR_LDAP_CANNOT_CANCEL: gpg_err_code_t = 889;
pub const gpg_err_code_t_GPG_ERR_LDAP_ASSERTION_FAILED: gpg_err_code_t = 890;
pub const gpg_err_code_t_GPG_ERR_LDAP_PROX_AUTH_DENIED: gpg_err_code_t = 891;
pub const gpg_err_code_t_GPG_ERR_USER_1: gpg_err_code_t = 1024;
pub const gpg_err_code_t_GPG_ERR_USER_2: gpg_err_code_t = 1025;
pub const gpg_err_code_t_GPG_ERR_USER_3: gpg_err_code_t = 1026;
pub const gpg_err_code_t_GPG_ERR_USER_4: gpg_err_code_t = 1027;
pub const gpg_err_code_t_GPG_ERR_USER_5: gpg_err_code_t = 1028;
pub const gpg_err_code_t_GPG_ERR_USER_6: gpg_err_code_t = 1029;
pub const gpg_err_code_t_GPG_ERR_USER_7: gpg_err_code_t = 1030;
pub const gpg_err_code_t_GPG_ERR_USER_8: gpg_err_code_t = 1031;
pub const gpg_err_code_t_GPG_ERR_USER_9: gpg_err_code_t = 1032;
pub const gpg_err_code_t_GPG_ERR_USER_10: gpg_err_code_t = 1033;
pub const gpg_err_code_t_GPG_ERR_USER_11: gpg_err_code_t = 1034;
pub const gpg_err_code_t_GPG_ERR_USER_12: gpg_err_code_t = 1035;
pub const gpg_err_code_t_GPG_ERR_USER_13: gpg_err_code_t = 1036;
pub const gpg_err_code_t_GPG_ERR_USER_14: gpg_err_code_t = 1037;
pub const gpg_err_code_t_GPG_ERR_USER_15: gpg_err_code_t = 1038;
pub const gpg_err_code_t_GPG_ERR_USER_16: gpg_err_code_t = 1039;
pub const gpg_err_code_t_GPG_ERR_MISSING_ERRNO: gpg_err_code_t = 16381;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_ERRNO: gpg_err_code_t = 16382;
pub const gpg_err_code_t_GPG_ERR_EOF: gpg_err_code_t = 16383;
pub const gpg_err_code_t_GPG_ERR_E2BIG: gpg_err_code_t = 32768;
pub const gpg_err_code_t_GPG_ERR_EACCES: gpg_err_code_t = 32769;
pub const gpg_err_code_t_GPG_ERR_EADDRINUSE: gpg_err_code_t = 32770;
pub const gpg_err_code_t_GPG_ERR_EADDRNOTAVAIL: gpg_err_code_t = 32771;
pub const gpg_err_code_t_GPG_ERR_EADV: gpg_err_code_t = 32772;
pub const gpg_err_code_t_GPG_ERR_EAFNOSUPPORT: gpg_err_code_t = 32773;
pub const gpg_err_code_t_GPG_ERR_EAGAIN: gpg_err_code_t = 32774;
pub const gpg_err_code_t_GPG_ERR_EALREADY: gpg_err_code_t = 32775;
pub const gpg_err_code_t_GPG_ERR_EAUTH: gpg_err_code_t = 32776;
pub const gpg_err_code_t_GPG_ERR_EBACKGROUND: gpg_err_code_t = 32777;
pub const gpg_err_code_t_GPG_ERR_EBADE: gpg_err_code_t = 32778;
pub const gpg_err_code_t_GPG_ERR_EBADF: gpg_err_code_t = 32779;
pub const gpg_err_code_t_GPG_ERR_EBADFD: gpg_err_code_t = 32780;
pub const gpg_err_code_t_GPG_ERR_EBADMSG: gpg_err_code_t = 32781;
pub const gpg_err_code_t_GPG_ERR_EBADR: gpg_err_code_t = 32782;
pub const gpg_err_code_t_GPG_ERR_EBADRPC: gpg_err_code_t = 32783;
pub const gpg_err_code_t_GPG_ERR_EBADRQC: gpg_err_code_t = 32784;
pub const gpg_err_code_t_GPG_ERR_EBADSLT: gpg_err_code_t = 32785;
pub const gpg_err_code_t_GPG_ERR_EBFONT: gpg_err_code_t = 32786;
pub const gpg_err_code_t_GPG_ERR_EBUSY: gpg_err_code_t = 32787;
pub const gpg_err_code_t_GPG_ERR_ECANCELED: gpg_err_code_t = 32788;
pub const gpg_err_code_t_GPG_ERR_ECHILD: gpg_err_code_t = 32789;
pub const gpg_err_code_t_GPG_ERR_ECHRNG: gpg_err_code_t = 32790;
pub const gpg_err_code_t_GPG_ERR_ECOMM: gpg_err_code_t = 32791;
pub const gpg_err_code_t_GPG_ERR_ECONNABORTED: gpg_err_code_t = 32792;
pub const gpg_err_code_t_GPG_ERR_ECONNREFUSED: gpg_err_code_t = 32793;
pub const gpg_err_code_t_GPG_ERR_ECONNRESET: gpg_err_code_t = 32794;
pub const gpg_err_code_t_GPG_ERR_ED: gpg_err_code_t = 32795;
pub const gpg_err_code_t_GPG_ERR_EDEADLK: gpg_err_code_t = 32796;
pub const gpg_err_code_t_GPG_ERR_EDEADLOCK: gpg_err_code_t = 32797;
pub const gpg_err_code_t_GPG_ERR_EDESTADDRREQ: gpg_err_code_t = 32798;
pub const gpg_err_code_t_GPG_ERR_EDIED: gpg_err_code_t = 32799;
pub const gpg_err_code_t_GPG_ERR_EDOM: gpg_err_code_t = 32800;
pub const gpg_err_code_t_GPG_ERR_EDOTDOT: gpg_err_code_t = 32801;
pub const gpg_err_code_t_GPG_ERR_EDQUOT: gpg_err_code_t = 32802;
pub const gpg_err_code_t_GPG_ERR_EEXIST: gpg_err_code_t = 32803;
pub const gpg_err_code_t_GPG_ERR_EFAULT: gpg_err_code_t = 32804;
pub const gpg_err_code_t_GPG_ERR_EFBIG: gpg_err_code_t = 32805;
pub const gpg_err_code_t_GPG_ERR_EFTYPE: gpg_err_code_t = 32806;
pub const gpg_err_code_t_GPG_ERR_EGRATUITOUS: gpg_err_code_t = 32807;
pub const gpg_err_code_t_GPG_ERR_EGREGIOUS: gpg_err_code_t = 32808;
pub const gpg_err_code_t_GPG_ERR_EHOSTDOWN: gpg_err_code_t = 32809;
pub const gpg_err_code_t_GPG_ERR_EHOSTUNREACH: gpg_err_code_t = 32810;
pub const gpg_err_code_t_GPG_ERR_EIDRM: gpg_err_code_t = 32811;
pub const gpg_err_code_t_GPG_ERR_EIEIO: gpg_err_code_t = 32812;
pub const gpg_err_code_t_GPG_ERR_EILSEQ: gpg_err_code_t = 32813;
pub const gpg_err_code_t_GPG_ERR_EINPROGRESS: gpg_err_code_t = 32814;
pub const gpg_err_code_t_GPG_ERR_EINTR: gpg_err_code_t = 32815;
pub const gpg_err_code_t_GPG_ERR_EINVAL: gpg_err_code_t = 32816;
pub const gpg_err_code_t_GPG_ERR_EIO: gpg_err_code_t = 32817;
pub const gpg_err_code_t_GPG_ERR_EISCONN: gpg_err_code_t = 32818;
pub const gpg_err_code_t_GPG_ERR_EISDIR: gpg_err_code_t = 32819;
pub const gpg_err_code_t_GPG_ERR_EISNAM: gpg_err_code_t = 32820;
pub const gpg_err_code_t_GPG_ERR_EL2HLT: gpg_err_code_t = 32821;
pub const gpg_err_code_t_GPG_ERR_EL2NSYNC: gpg_err_code_t = 32822;
pub const gpg_err_code_t_GPG_ERR_EL3HLT: gpg_err_code_t = 32823;
pub const gpg_err_code_t_GPG_ERR_EL3RST: gpg_err_code_t = 32824;
pub const gpg_err_code_t_GPG_ERR_ELIBACC: gpg_err_code_t = 32825;
pub const gpg_err_code_t_GPG_ERR_ELIBBAD: gpg_err_code_t = 32826;
pub const gpg_err_code_t_GPG_ERR_ELIBEXEC: gpg_err_code_t = 32827;
pub const gpg_err_code_t_GPG_ERR_ELIBMAX: gpg_err_code_t = 32828;
pub const gpg_err_code_t_GPG_ERR_ELIBSCN: gpg_err_code_t = 32829;
pub const gpg_err_code_t_GPG_ERR_ELNRNG: gpg_err_code_t = 32830;
pub const gpg_err_code_t_GPG_ERR_ELOOP: gpg_err_code_t = 32831;
pub const gpg_err_code_t_GPG_ERR_EMEDIUMTYPE: gpg_err_code_t = 32832;
pub const gpg_err_code_t_GPG_ERR_EMFILE: gpg_err_code_t = 32833;
pub const gpg_err_code_t_GPG_ERR_EMLINK: gpg_err_code_t = 32834;
pub const gpg_err_code_t_GPG_ERR_EMSGSIZE: gpg_err_code_t = 32835;
pub const gpg_err_code_t_GPG_ERR_EMULTIHOP: gpg_err_code_t = 32836;
pub const gpg_err_code_t_GPG_ERR_ENAMETOOLONG: gpg_err_code_t = 32837;
pub const gpg_err_code_t_GPG_ERR_ENAVAIL: gpg_err_code_t = 32838;
pub const gpg_err_code_t_GPG_ERR_ENEEDAUTH: gpg_err_code_t = 32839;
pub const gpg_err_code_t_GPG_ERR_ENETDOWN: gpg_err_code_t = 32840;
pub const gpg_err_code_t_GPG_ERR_ENETRESET: gpg_err_code_t = 32841;
pub const gpg_err_code_t_GPG_ERR_ENETUNREACH: gpg_err_code_t = 32842;
pub const gpg_err_code_t_GPG_ERR_ENFILE: gpg_err_code_t = 32843;
pub const gpg_err_code_t_GPG_ERR_ENOANO: gpg_err_code_t = 32844;
pub const gpg_err_code_t_GPG_ERR_ENOBUFS: gpg_err_code_t = 32845;
pub const gpg_err_code_t_GPG_ERR_ENOCSI: gpg_err_code_t = 32846;
pub const gpg_err_code_t_GPG_ERR_ENODATA: gpg_err_code_t = 32847;
pub const gpg_err_code_t_GPG_ERR_ENODEV: gpg_err_code_t = 32848;
pub const gpg_err_code_t_GPG_ERR_ENOENT: gpg_err_code_t = 32849;
pub const gpg_err_code_t_GPG_ERR_ENOEXEC: gpg_err_code_t = 32850;
pub const gpg_err_code_t_GPG_ERR_ENOLCK: gpg_err_code_t = 32851;
pub const gpg_err_code_t_GPG_ERR_ENOLINK: gpg_err_code_t = 32852;
pub const gpg_err_code_t_GPG_ERR_ENOMEDIUM: gpg_err_code_t = 32853;
pub const gpg_err_code_t_GPG_ERR_ENOMEM: gpg_err_code_t = 32854;
pub const gpg_err_code_t_GPG_ERR_ENOMSG: gpg_err_code_t = 32855;
pub const gpg_err_code_t_GPG_ERR_ENONET: gpg_err_code_t = 32856;
pub const gpg_err_code_t_GPG_ERR_ENOPKG: gpg_err_code_t = 32857;
pub const gpg_err_code_t_GPG_ERR_ENOPROTOOPT: gpg_err_code_t = 32858;
pub const gpg_err_code_t_GPG_ERR_ENOSPC: gpg_err_code_t = 32859;
pub const gpg_err_code_t_GPG_ERR_ENOSR: gpg_err_code_t = 32860;
pub const gpg_err_code_t_GPG_ERR_ENOSTR: gpg_err_code_t = 32861;
pub const gpg_err_code_t_GPG_ERR_ENOSYS: gpg_err_code_t = 32862;
pub const gpg_err_code_t_GPG_ERR_ENOTBLK: gpg_err_code_t = 32863;
pub const gpg_err_code_t_GPG_ERR_ENOTCONN: gpg_err_code_t = 32864;
pub const gpg_err_code_t_GPG_ERR_ENOTDIR: gpg_err_code_t = 32865;
pub const gpg_err_code_t_GPG_ERR_ENOTEMPTY: gpg_err_code_t = 32866;
pub const gpg_err_code_t_GPG_ERR_ENOTNAM: gpg_err_code_t = 32867;
pub const gpg_err_code_t_GPG_ERR_ENOTSOCK: gpg_err_code_t = 32868;
pub const gpg_err_code_t_GPG_ERR_ENOTSUP: gpg_err_code_t = 32869;
pub const gpg_err_code_t_GPG_ERR_ENOTTY: gpg_err_code_t = 32870;
pub const gpg_err_code_t_GPG_ERR_ENOTUNIQ: gpg_err_code_t = 32871;
pub const gpg_err_code_t_GPG_ERR_ENXIO: gpg_err_code_t = 32872;
pub const gpg_err_code_t_GPG_ERR_EOPNOTSUPP: gpg_err_code_t = 32873;
pub const gpg_err_code_t_GPG_ERR_EOVERFLOW: gpg_err_code_t = 32874;
pub const gpg_err_code_t_GPG_ERR_EPERM: gpg_err_code_t = 32875;
pub const gpg_err_code_t_GPG_ERR_EPFNOSUPPORT: gpg_err_code_t = 32876;
pub const gpg_err_code_t_GPG_ERR_EPIPE: gpg_err_code_t = 32877;
pub const gpg_err_code_t_GPG_ERR_EPROCLIM: gpg_err_code_t = 32878;
pub const gpg_err_code_t_GPG_ERR_EPROCUNAVAIL: gpg_err_code_t = 32879;
pub const gpg_err_code_t_GPG_ERR_EPROGMISMATCH: gpg_err_code_t = 32880;
pub const gpg_err_code_t_GPG_ERR_EPROGUNAVAIL: gpg_err_code_t = 32881;
pub const gpg_err_code_t_GPG_ERR_EPROTO: gpg_err_code_t = 32882;
pub const gpg_err_code_t_GPG_ERR_EPROTONOSUPPORT: gpg_err_code_t = 32883;
pub const gpg_err_code_t_GPG_ERR_EPROTOTYPE: gpg_err_code_t = 32884;
pub const gpg_err_code_t_GPG_ERR_ERANGE: gpg_err_code_t = 32885;
pub const gpg_err_code_t_GPG_ERR_EREMCHG: gpg_err_code_t = 32886;
pub const gpg_err_code_t_GPG_ERR_EREMOTE: gpg_err_code_t = 32887;
pub const gpg_err_code_t_GPG_ERR_EREMOTEIO: gpg_err_code_t = 32888;
pub const gpg_err_code_t_GPG_ERR_ERESTART: gpg_err_code_t = 32889;
pub const gpg_err_code_t_GPG_ERR_EROFS: gpg_err_code_t = 32890;
pub const gpg_err_code_t_GPG_ERR_ERPCMISMATCH: gpg_err_code_t = 32891;
pub const gpg_err_code_t_GPG_ERR_ESHUTDOWN: gpg_err_code_t = 32892;
pub const gpg_err_code_t_GPG_ERR_ESOCKTNOSUPPORT: gpg_err_code_t = 32893;
pub const gpg_err_code_t_GPG_ERR_ESPIPE: gpg_err_code_t = 32894;
pub const gpg_err_code_t_GPG_ERR_ESRCH: gpg_err_code_t = 32895;
pub const gpg_err_code_t_GPG_ERR_ESRMNT: gpg_err_code_t = 32896;
pub const gpg_err_code_t_GPG_ERR_ESTALE: gpg_err_code_t = 32897;
pub const gpg_err_code_t_GPG_ERR_ESTRPIPE: gpg_err_code_t = 32898;
pub const gpg_err_code_t_GPG_ERR_ETIME: gpg_err_code_t = 32899;
pub const gpg_err_code_t_GPG_ERR_ETIMEDOUT: gpg_err_code_t = 32900;
pub const gpg_err_code_t_GPG_ERR_ETOOMANYREFS: gpg_err_code_t = 32901;
pub const gpg_err_code_t_GPG_ERR_ETXTBSY: gpg_err_code_t = 32902;
pub const gpg_err_code_t_GPG_ERR_EUCLEAN: gpg_err_code_t = 32903;
pub const gpg_err_code_t_GPG_ERR_EUNATCH: gpg_err_code_t = 32904;
pub const gpg_err_code_t_GPG_ERR_EUSERS: gpg_err_code_t = 32905;
pub const gpg_err_code_t_GPG_ERR_EWOULDBLOCK: gpg_err_code_t = 32906;
pub const gpg_err_code_t_GPG_ERR_EXDEV: gpg_err_code_t = 32907;
pub const gpg_err_code_t_GPG_ERR_EXFULL: gpg_err_code_t = 32908;
pub const gpg_err_code_t_GPG_ERR_CODE_DIM: gpg_err_code_t = 65536;
pub type gpg_err_code_t = u32;
pub type gpg_error_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gpg_err_init() -> gpg_error_t;
}
extern "C" {
    pub fn gpg_err_deinit(mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_set_syscall_clamp(
        pre: ::std::option::Option<unsafe extern "C" fn()>,
        post: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn gpgrt_get_syscall_clamp(
        r_pre: *mut ::std::option::Option<unsafe extern "C" fn()>,
        r_post: *mut ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn gpgrt_set_alloc_func(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                a: *mut ::std::os::raw::c_void,
                n: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    );
}
extern "C" {
    pub fn gpgrt_add_emergency_cleanup(f: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn gpgrt_abort();
}
extern "C" {
    pub fn gpg_strerror(err: gpg_error_t) -> *const ::std::os::raw::c_char;
}
pub type gpg_strerror_r = unsafe extern "C" fn(
    err: gpg_error_t,
    buf: *mut ::std::os::raw::c_char,
    buflen: usize,
) -> ::std::os::raw::c_int;
extern "C" {
    pub fn gpg_strsource(err: gpg_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpg_err_code_from_errno(err: ::std::os::raw::c_int) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpg_err_code_to_errno(code: gpg_err_code_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpg_err_code_from_syserror() -> gpg_err_code_t;
}
extern "C" {
    pub fn gpg_err_set_errno(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpg_error_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type gpgrt_ssize_t = isize;
pub type gpgrt_off_t = ::std::os::raw::c_long;
extern "C" {
    pub fn gpgrt_realloc(a: *mut ::std::os::raw::c_void, n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_malloc(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_calloc(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_strdup(string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_strconcat(s1: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_free(a: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgrt_getenv(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_mkdir(
        name: *const ::std::os::raw::c_char,
        modestr: *const ::std::os::raw::c_char,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_chdir(name: *const ::std::os::raw::c_char) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_getcwd() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgrt_lock_t {
    pub _vers: ::std::os::raw::c_long,
    pub u: gpgrt_lock_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgrt_lock_t__bindgen_ty_1 {
    pub _priv: [::std::os::raw::c_char; 40usize],
    pub _x_align: ::std::os::raw::c_long,
    pub _xp_align: *mut ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_gpgrt_lock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_lock_t__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(gpgrt_lock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_lock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_lock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._priv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_priv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._x_align as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_x_align)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._xp_align as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_xp_align)
        )
    );
}
#[test]
fn bindgen_test_layout_gpgrt_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_lock_t>(),
        48usize,
        concat!("Size of: ", stringify!(gpgrt_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_lock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_lock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_lock_t>()))._vers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t),
            "::",
            stringify!(_vers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_lock_t>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn gpgrt_lock_init(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_lock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_trylock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_unlock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_destroy(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_yield() -> gpg_err_code_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_stream_internal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt__stream {
    pub flags: _gpgrt__stream__bindgen_ty_1,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub buffer_size: usize,
    pub data_len: usize,
    pub data_offset: usize,
    pub data_flushed: usize,
    pub unread_buffer: *mut ::std::os::raw::c_uchar,
    pub unread_buffer_size: usize,
    pub unread_data_len: usize,
    pub intern: *mut _gpgrt_stream_internal,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt__stream__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout__gpgrt__stream__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_gpgrt__stream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_gpgrt__stream__bindgen_ty_1))
    );
}
impl _gpgrt__stream__bindgen_ty_1 {
    #[inline]
    pub fn magic(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_magic(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn writing(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_writing(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        magic: ::std::os::raw::c_uint,
        writing: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let magic: u32 = unsafe { ::std::mem::transmute(magic) };
            magic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let writing: u32 = unsafe { ::std::mem::transmute(writing) };
            writing as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__gpgrt__stream() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt__stream>(),
        80usize,
        concat!("Size of: ", stringify!(_gpgrt__stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt__stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt__stream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_flushed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_flushed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).unread_buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt__stream>())).unread_buffer_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).unread_data_len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).intern as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(intern)
        )
    );
}
pub type gpgrt_stream_t = *mut _gpgrt__stream;
pub type gpgrt_cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgrt_cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgrt_cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        pos: *mut gpgrt_off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type gpgrt_cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_cookie_io_functions {
    pub func_read: gpgrt_cookie_read_function_t,
    pub func_write: gpgrt_cookie_write_function_t,
    pub func_seek: gpgrt_cookie_seek_function_t,
    pub func_close: gpgrt_cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__gpgrt_cookie_io_functions() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_cookie_io_functions>(),
        32usize,
        concat!("Size of: ", stringify!(_gpgrt_cookie_io_functions))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_cookie_io_functions>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_cookie_io_functions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_read as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_write as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_seek as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_close as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_close)
        )
    );
}
pub type gpgrt_cookie_io_functions_t = _gpgrt_cookie_io_functions;
pub const gpgrt_syshd_types_GPGRT_SYSHD_NONE: gpgrt_syshd_types = 0;
pub const gpgrt_syshd_types_GPGRT_SYSHD_FD: gpgrt_syshd_types = 1;
pub const gpgrt_syshd_types_GPGRT_SYSHD_SOCK: gpgrt_syshd_types = 2;
pub const gpgrt_syshd_types_GPGRT_SYSHD_RVID: gpgrt_syshd_types = 3;
pub const gpgrt_syshd_types_GPGRT_SYSHD_HANDLE: gpgrt_syshd_types = 4;
pub type gpgrt_syshd_types = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _gpgrt_syshd {
    pub type_: gpgrt_syshd_types,
    pub u: _gpgrt_syshd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _gpgrt_syshd__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub sock: ::std::os::raw::c_int,
    pub rvid: ::std::os::raw::c_int,
    pub handle: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gpgrt_syshd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_syshd__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_gpgrt_syshd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_syshd__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_syshd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).sock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).rvid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(rvid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout__gpgrt_syshd() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_syshd>(),
        16usize,
        concat!("Size of: ", stringify!(_gpgrt_syshd))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_syshd>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_syshd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd),
            "::",
            stringify!(u)
        )
    );
}
pub type gpgrt_syshd_t = _gpgrt_syshd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_poll_s {
    pub stream: gpgrt_stream_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__gpgrt_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_poll_s>(),
        16usize,
        concat!("Size of: ", stringify!(_gpgrt_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_poll_s>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_poll_s),
            "::",
            stringify!(stream)
        )
    );
}
impl _gpgrt_poll_s {
    #[inline]
    pub fn want_read(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_read(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_write(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_write(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_oob(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_oob(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_rdhup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_rdhup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn got_read(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_read(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_write(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_write(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_oob(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_oob(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_rdhup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_rdhup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn got_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_hup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_hup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_nval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_nval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_user(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_read: ::std::os::raw::c_uint,
        want_write: ::std::os::raw::c_uint,
        want_oob: ::std::os::raw::c_uint,
        want_rdhup: ::std::os::raw::c_uint,
        _reserv1: ::std::os::raw::c_uint,
        got_read: ::std::os::raw::c_uint,
        got_write: ::std::os::raw::c_uint,
        got_oob: ::std::os::raw::c_uint,
        got_rdhup: ::std::os::raw::c_uint,
        _reserv2: ::std::os::raw::c_uint,
        got_err: ::std::os::raw::c_uint,
        got_hup: ::std::os::raw::c_uint,
        got_nval: ::std::os::raw::c_uint,
        _reserv3: ::std::os::raw::c_uint,
        ignore: ::std::os::raw::c_uint,
        user: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_read: u32 = unsafe { ::std::mem::transmute(want_read) };
            want_read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let want_write: u32 = unsafe { ::std::mem::transmute(want_write) };
            want_write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let want_oob: u32 = unsafe { ::std::mem::transmute(want_oob) };
            want_oob as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let want_rdhup: u32 = unsafe { ::std::mem::transmute(want_rdhup) };
            want_rdhup as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _reserv1: u32 = unsafe { ::std::mem::transmute(_reserv1) };
            _reserv1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let got_read: u32 = unsafe { ::std::mem::transmute(got_read) };
            got_read as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let got_write: u32 = unsafe { ::std::mem::transmute(got_write) };
            got_write as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let got_oob: u32 = unsafe { ::std::mem::transmute(got_oob) };
            got_oob as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let got_rdhup: u32 = unsafe { ::std::mem::transmute(got_rdhup) };
            got_rdhup as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let _reserv2: u32 = unsafe { ::std::mem::transmute(_reserv2) };
            _reserv2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let got_err: u32 = unsafe { ::std::mem::transmute(got_err) };
            got_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let got_hup: u32 = unsafe { ::std::mem::transmute(got_hup) };
            got_hup as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let got_nval: u32 = unsafe { ::std::mem::transmute(got_nval) };
            got_nval as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let _reserv3: u32 = unsafe { ::std::mem::transmute(_reserv3) };
            _reserv3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ignore: u32 = unsafe { ::std::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let user: u32 = unsafe { ::std::mem::transmute(user) };
            user as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgrt_poll_t = _gpgrt_poll_s;
pub type gpgrt_string_filter_t = ::std::option::Option<
    unsafe extern "C" fn(
        s: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn gpgrt_fopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_mopen(
        data: *mut ::std::os::raw::c_void,
        data_n: usize,
        data_len: usize,
        grow: ::std::os::raw::c_uint,
        func_realloc: ::std::option::Option<
            unsafe extern "C" fn(
                mem: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        func_free: ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopenmem(memlimit: usize, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopenmem_init(
        memlimit: usize,
        mode: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        datalen: usize,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fdopen(
        filedes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fdopen_nc(
        filedes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_sysopen(
        syshd: *mut gpgrt_syshd_t,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_sysopen_nc(
        syshd: *mut gpgrt_syshd_t,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fpopen(fp: *mut FILE, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fpopen_nc(fp: *mut FILE, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_freopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopencookie(
        cookie: *mut ::std::os::raw::c_void,
        mode: *const ::std::os::raw::c_char,
        functions: gpgrt_cookie_io_functions_t,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fclose(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fclose_snatch(
        stream: gpgrt_stream_t,
        r_buffer: *mut *mut ::std::os::raw::c_void,
        r_buflen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_onclose(
        stream: gpgrt_stream_t,
        mode: ::std::os::raw::c_int,
        fnc: ::std::option::Option<
            unsafe extern "C" fn(arg1: gpgrt_stream_t, arg2: *mut ::std::os::raw::c_void),
        >,
        fnc_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fileno(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fileno_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_syshd(stream: gpgrt_stream_t, syshd: *mut gpgrt_syshd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_syshd_unlocked(
        stream: gpgrt_stream_t,
        syshd: *mut gpgrt_syshd_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_set_std_fd(no: ::std::os::raw::c_int, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _gpgrt_get_std_stream(fd: ::std::os::raw::c_int) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_flockfile(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_ftrylockfile(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_funlockfile(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_feof(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_feof_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ferror(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ferror_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_clearerr(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_clearerr_unlocked(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn _gpgrt_pending(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_pending_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fflush(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fseek(
        stream: gpgrt_stream_t,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fseeko(
        stream: gpgrt_stream_t,
        offset: gpgrt_off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ftruncate(stream: gpgrt_stream_t, length: gpgrt_off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ftell(stream: gpgrt_stream_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn gpgrt_ftello(stream: gpgrt_stream_t) -> gpgrt_off_t;
}
extern "C" {
    pub fn gpgrt_rewind(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_fgetc(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fputc(c: ::std::os::raw::c_int, stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_getc_underflow(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_putc_overflow(
        c: ::std::os::raw::c_int,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ungetc(c: ::std::os::raw::c_int, stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_read(
        stream: gpgrt_stream_t,
        buffer: *mut ::std::os::raw::c_void,
        bytes_to_read: usize,
        bytes_read: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        bytes_to_write: usize,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write_sanitized(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        delimiters: *const ::std::os::raw::c_char,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write_hexstring(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        reserved: ::std::os::raw::c_int,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fread(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: gpgrt_stream_t,
    ) -> usize;
}
extern "C" {
    pub fn gpgrt_fwrite(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: gpgrt_stream_t,
    ) -> usize;
}
extern "C" {
    pub fn gpgrt_fgets(
        s: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        stream: gpgrt_stream_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_fputs(
        s: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fputs_unlocked(
        s: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_getline(
        lineptr: *mut *mut ::std::os::raw::c_char,
        n: *mut usize,
        stream: gpgrt_stream_t,
    ) -> isize;
}
extern "C" {
    pub fn gpgrt_read_line(
        stream: gpgrt_stream_t,
        addr_of_buffer: *mut *mut ::std::os::raw::c_char,
        length_of_buffer: *mut usize,
        max_length: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn gpgrt_fprintf(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_unlocked(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_sf(
        stream: gpgrt_stream_t,
        sf: gpgrt_string_filter_t,
        sfvalue: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_sf_unlocked(
        stream: gpgrt_stream_t,
        sf: gpgrt_string_filter_t,
        sfvalue: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_printf_unlocked(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vfprintf(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vfprintf_unlocked(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_setvbuf(
        stream: gpgrt_stream_t,
        buf: *mut ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_setbuf(stream: gpgrt_stream_t, buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_set_binary(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_set_nonblock(
        stream: gpgrt_stream_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_get_nonblock(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_poll(
        fdlist: *mut gpgrt_poll_t,
        nfds: ::std::os::raw::c_uint,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_tmpfile() -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_opaque_set(stream: gpgrt_stream_t, opaque: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgrt_opaque_get(stream: gpgrt_stream_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_fname_set(stream: gpgrt_stream_t, fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_fname_get(stream: gpgrt_stream_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_asprintf(
        r_buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vasprintf(
        r_buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_bsprintf(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_vbsprintf(
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_snprintf(
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        format: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_b64state {
    _unused: [u8; 0],
}
pub type gpgrt_b64state_t = *mut _gpgrt_b64state;
extern "C" {
    pub fn gpgrt_b64enc_start(
        stream: gpgrt_stream_t,
        title: *const ::std::os::raw::c_char,
    ) -> gpgrt_b64state_t;
}
extern "C" {
    pub fn gpgrt_b64enc_write(
        state: gpgrt_b64state_t,
        buffer: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_b64enc_finish(state: gpgrt_b64state_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_b64dec_start(title: *const ::std::os::raw::c_char) -> gpgrt_b64state_t;
}
extern "C" {
    pub fn gpgrt_b64dec_proc(
        state: gpgrt_b64state_t,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        r_nbytes: *mut usize,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gpgrt_b64dec_finish(state: gpgrt_b64state_t) -> gpg_error_t;
}
pub const gpgrt_log_levels_GPGRT_LOGLVL_BEGIN: gpgrt_log_levels = 0;
pub const gpgrt_log_levels_GPGRT_LOGLVL_CONT: gpgrt_log_levels = 1;
pub const gpgrt_log_levels_GPGRT_LOGLVL_INFO: gpgrt_log_levels = 2;
pub const gpgrt_log_levels_GPGRT_LOGLVL_WARN: gpgrt_log_levels = 3;
pub const gpgrt_log_levels_GPGRT_LOGLVL_ERROR: gpgrt_log_levels = 4;
pub const gpgrt_log_levels_GPGRT_LOGLVL_FATAL: gpgrt_log_levels = 5;
pub const gpgrt_log_levels_GPGRT_LOGLVL_BUG: gpgrt_log_levels = 6;
pub const gpgrt_log_levels_GPGRT_LOGLVL_DEBUG: gpgrt_log_levels = 7;
pub type gpgrt_log_levels = u32;
extern "C" {
    pub fn gpgrt_log_set_sink(
        name: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
        fd: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gpgrt_log_set_socket_dir_cb(
        fnc: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    );
}
extern "C" {
    pub fn gpgrt_log_set_pid_suffix_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(r_value: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn gpgrt_log_set_prefix(text: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gpgrt_get_errorcount(clear: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_inc_errorcount();
}
extern "C" {
    pub fn gpgrt_log_get_prefix(
        flags: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_log_test_fd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_log_get_fd() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_log_get_stream() -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_log(level: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_logv(
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn gpgrt_logv_prefix(
        level: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn gpgrt_log_string(level: ::std::os::raw::c_int, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_log_bug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_fatal(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_info(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_debug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_debug_string(
        string: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gpgrt_log_printf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_printhex(
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gpgrt_log_clock(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_flush();
}
extern "C" {
    pub fn _gpgrt_log_assert(
        expr: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_argparse_internal_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgrt_argparse_t {
    pub argc: *mut ::std::os::raw::c_int,
    pub argv: *mut *mut *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub err: ::std::os::raw::c_int,
    pub lineno: ::std::os::raw::c_uint,
    pub r_opt: ::std::os::raw::c_int,
    pub r_type: ::std::os::raw::c_int,
    pub r: gpgrt_argparse_t__bindgen_ty_1,
    pub internal: *mut _gpgrt_argparse_internal_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgrt_argparse_t__bindgen_ty_1 {
    pub ret_int: ::std::os::raw::c_int,
    pub ret_long: ::std::os::raw::c_long,
    pub ret_ulong: ::std::os::raw::c_ulong,
    pub ret_str: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gpgrt_argparse_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_argparse_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gpgrt_argparse_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_argparse_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_argparse_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_int as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_int)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_long as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_ulong as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_ulong)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_str)
        )
    );
}
#[test]
fn bindgen_test_layout_gpgrt_argparse_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_argparse_t>(),
        56usize,
        concat!("Size of: ", stringify!(gpgrt_argparse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_argparse_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_argparse_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).argv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).err as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).lineno as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r_opt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).internal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgrt_opt_t {
    pub short_opt: ::std::os::raw::c_int,
    pub long_opt: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gpgrt_opt_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_opt_t>(),
        32usize,
        concat!("Size of: ", stringify!(gpgrt_opt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_opt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).short_opt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(short_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).long_opt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(long_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(description)
        )
    );
}
extern "C" {
    pub fn gpgrt_argparse(
        fp: gpgrt_stream_t,
        arg: *mut gpgrt_argparse_t,
        opts: *mut gpgrt_opt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_usage(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_strusage(level: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_set_strusage(
        f: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        >,
    );
}
extern "C" {
    pub fn gpgrt_set_usage_outfnc(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn gpgrt_set_fixed_string_mapper(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char,
        >,
    );
}
extern "C" {
    pub fn gpgrt_cmp_version(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type gpgme_off_t = off_t;
pub type gpgme_ssize_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_context {
    _unused: [u8; 0],
}
pub type gpgme_ctx_t = *mut gpgme_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_data {
    _unused: [u8; 0],
}
pub type gpgme_data_t = *mut gpgme_data;
pub type gpgme_error_t = gpg_error_t;
pub use self::gpg_err_code_t as gpgme_err_code_t;
pub use self::gpg_err_source_t as gpgme_err_source_t;
extern "C" {
    pub fn gpgme_strerror(err: gpgme_error_t) -> *const ::std::os::raw::c_char;
}
pub type gpgme_strerror_r = unsafe extern "C" fn(
    err: gpg_error_t,
    buf: *mut ::std::os::raw::c_char,
    buflen: usize,
) -> ::std::os::raw::c_int;
extern "C" {
    pub fn gpgme_strsource(err: gpgme_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_err_code_from_errno(err: ::std::os::raw::c_int) -> gpgme_err_code_t;
}
extern "C" {
    pub fn gpgme_err_code_to_errno(code: gpgme_err_code_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgme_err_code_from_syserror() -> gpgme_err_code_t;
}
extern "C" {
    pub fn gpgme_err_set_errno(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgme_err_make_from_errno(
        source: gpgme_err_source_t,
        err: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_error_from_errno(err: ::std::os::raw::c_int) -> gpgme_error_t;
}
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_NONE: gpgme_data_encoding_t = 0;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_BINARY: gpgme_data_encoding_t = 1;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_BASE64: gpgme_data_encoding_t = 2;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_ARMOR: gpgme_data_encoding_t = 3;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_URL: gpgme_data_encoding_t = 4;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_URLESC: gpgme_data_encoding_t = 5;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_URL0: gpgme_data_encoding_t = 6;
pub const gpgme_data_encoding_t_GPGME_DATA_ENCODING_MIME: gpgme_data_encoding_t = 7;
pub type gpgme_data_encoding_t = u32;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_INVALID: gpgme_data_type_t = 0;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_UNKNOWN: gpgme_data_type_t = 1;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PGP_SIGNED: gpgme_data_type_t = 16;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PGP_ENCRYPTED: gpgme_data_type_t = 17;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PGP_OTHER: gpgme_data_type_t = 18;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PGP_KEY: gpgme_data_type_t = 19;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PGP_SIGNATURE: gpgme_data_type_t = 24;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_CMS_SIGNED: gpgme_data_type_t = 32;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_CMS_ENCRYPTED: gpgme_data_type_t = 33;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_CMS_OTHER: gpgme_data_type_t = 34;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_X509_CERT: gpgme_data_type_t = 35;
pub const gpgme_data_type_t_GPGME_DATA_TYPE_PKCS12: gpgme_data_type_t = 36;
pub type gpgme_data_type_t = u32;
pub const gpgme_pubkey_algo_t_GPGME_PK_RSA: gpgme_pubkey_algo_t = 1;
pub const gpgme_pubkey_algo_t_GPGME_PK_RSA_E: gpgme_pubkey_algo_t = 2;
pub const gpgme_pubkey_algo_t_GPGME_PK_RSA_S: gpgme_pubkey_algo_t = 3;
pub const gpgme_pubkey_algo_t_GPGME_PK_ELG_E: gpgme_pubkey_algo_t = 16;
pub const gpgme_pubkey_algo_t_GPGME_PK_DSA: gpgme_pubkey_algo_t = 17;
pub const gpgme_pubkey_algo_t_GPGME_PK_ECC: gpgme_pubkey_algo_t = 18;
pub const gpgme_pubkey_algo_t_GPGME_PK_ELG: gpgme_pubkey_algo_t = 20;
pub const gpgme_pubkey_algo_t_GPGME_PK_ECDSA: gpgme_pubkey_algo_t = 301;
pub const gpgme_pubkey_algo_t_GPGME_PK_ECDH: gpgme_pubkey_algo_t = 302;
pub const gpgme_pubkey_algo_t_GPGME_PK_EDDSA: gpgme_pubkey_algo_t = 303;
pub type gpgme_pubkey_algo_t = u32;
pub const gpgme_hash_algo_t_GPGME_MD_NONE: gpgme_hash_algo_t = 0;
pub const gpgme_hash_algo_t_GPGME_MD_MD5: gpgme_hash_algo_t = 1;
pub const gpgme_hash_algo_t_GPGME_MD_SHA1: gpgme_hash_algo_t = 2;
pub const gpgme_hash_algo_t_GPGME_MD_RMD160: gpgme_hash_algo_t = 3;
pub const gpgme_hash_algo_t_GPGME_MD_MD2: gpgme_hash_algo_t = 5;
pub const gpgme_hash_algo_t_GPGME_MD_TIGER: gpgme_hash_algo_t = 6;
pub const gpgme_hash_algo_t_GPGME_MD_HAVAL: gpgme_hash_algo_t = 7;
pub const gpgme_hash_algo_t_GPGME_MD_SHA256: gpgme_hash_algo_t = 8;
pub const gpgme_hash_algo_t_GPGME_MD_SHA384: gpgme_hash_algo_t = 9;
pub const gpgme_hash_algo_t_GPGME_MD_SHA512: gpgme_hash_algo_t = 10;
pub const gpgme_hash_algo_t_GPGME_MD_SHA224: gpgme_hash_algo_t = 11;
pub const gpgme_hash_algo_t_GPGME_MD_MD4: gpgme_hash_algo_t = 301;
pub const gpgme_hash_algo_t_GPGME_MD_CRC32: gpgme_hash_algo_t = 302;
pub const gpgme_hash_algo_t_GPGME_MD_CRC32_RFC1510: gpgme_hash_algo_t = 303;
pub const gpgme_hash_algo_t_GPGME_MD_CRC24_RFC2440: gpgme_hash_algo_t = 304;
pub type gpgme_hash_algo_t = u32;
pub const gpgme_sig_mode_t_GPGME_SIG_MODE_NORMAL: gpgme_sig_mode_t = 0;
pub const gpgme_sig_mode_t_GPGME_SIG_MODE_DETACH: gpgme_sig_mode_t = 1;
pub const gpgme_sig_mode_t_GPGME_SIG_MODE_CLEAR: gpgme_sig_mode_t = 2;
pub type gpgme_sig_mode_t = u32;
pub const gpgme_validity_t_GPGME_VALIDITY_UNKNOWN: gpgme_validity_t = 0;
pub const gpgme_validity_t_GPGME_VALIDITY_UNDEFINED: gpgme_validity_t = 1;
pub const gpgme_validity_t_GPGME_VALIDITY_NEVER: gpgme_validity_t = 2;
pub const gpgme_validity_t_GPGME_VALIDITY_MARGINAL: gpgme_validity_t = 3;
pub const gpgme_validity_t_GPGME_VALIDITY_FULL: gpgme_validity_t = 4;
pub const gpgme_validity_t_GPGME_VALIDITY_ULTIMATE: gpgme_validity_t = 5;
pub type gpgme_validity_t = u32;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_NONE: gpgme_tofu_policy_t = 0;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_AUTO: gpgme_tofu_policy_t = 1;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_GOOD: gpgme_tofu_policy_t = 2;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_UNKNOWN: gpgme_tofu_policy_t = 3;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_BAD: gpgme_tofu_policy_t = 4;
pub const gpgme_tofu_policy_t_GPGME_TOFU_POLICY_ASK: gpgme_tofu_policy_t = 5;
pub type gpgme_tofu_policy_t = u32;
pub const gpgme_keyorg_t_GPGME_KEYORG_UNKNOWN: gpgme_keyorg_t = 0;
pub const gpgme_keyorg_t_GPGME_KEYORG_KS: gpgme_keyorg_t = 1;
pub const gpgme_keyorg_t_GPGME_KEYORG_DANE: gpgme_keyorg_t = 3;
pub const gpgme_keyorg_t_GPGME_KEYORG_WKD: gpgme_keyorg_t = 4;
pub const gpgme_keyorg_t_GPGME_KEYORG_URL: gpgme_keyorg_t = 5;
pub const gpgme_keyorg_t_GPGME_KEYORG_FILE: gpgme_keyorg_t = 6;
pub const gpgme_keyorg_t_GPGME_KEYORG_SELF: gpgme_keyorg_t = 7;
pub const gpgme_keyorg_t_GPGME_KEYORG_OTHER: gpgme_keyorg_t = 31;
pub type gpgme_keyorg_t = u32;
pub const gpgme_protocol_t_GPGME_PROTOCOL_OpenPGP: gpgme_protocol_t = 0;
pub const gpgme_protocol_t_GPGME_PROTOCOL_CMS: gpgme_protocol_t = 1;
pub const gpgme_protocol_t_GPGME_PROTOCOL_GPGCONF: gpgme_protocol_t = 2;
pub const gpgme_protocol_t_GPGME_PROTOCOL_ASSUAN: gpgme_protocol_t = 3;
pub const gpgme_protocol_t_GPGME_PROTOCOL_G13: gpgme_protocol_t = 4;
pub const gpgme_protocol_t_GPGME_PROTOCOL_UISERVER: gpgme_protocol_t = 5;
pub const gpgme_protocol_t_GPGME_PROTOCOL_SPAWN: gpgme_protocol_t = 6;
pub const gpgme_protocol_t_GPGME_PROTOCOL_DEFAULT: gpgme_protocol_t = 254;
pub const gpgme_protocol_t_GPGME_PROTOCOL_UNKNOWN: gpgme_protocol_t = 255;
pub type gpgme_protocol_t = u32;
pub type gpgme_keylist_mode_t = ::std::os::raw::c_uint;
pub const gpgme_pinentry_mode_t_GPGME_PINENTRY_MODE_DEFAULT: gpgme_pinentry_mode_t = 0;
pub const gpgme_pinentry_mode_t_GPGME_PINENTRY_MODE_ASK: gpgme_pinentry_mode_t = 1;
pub const gpgme_pinentry_mode_t_GPGME_PINENTRY_MODE_CANCEL: gpgme_pinentry_mode_t = 2;
pub const gpgme_pinentry_mode_t_GPGME_PINENTRY_MODE_ERROR: gpgme_pinentry_mode_t = 3;
pub const gpgme_pinentry_mode_t_GPGME_PINENTRY_MODE_LOOPBACK: gpgme_pinentry_mode_t = 4;
pub type gpgme_pinentry_mode_t = u32;
pub type gpgme_export_mode_t = ::std::os::raw::c_uint;
pub type gpgme_sig_notation_flags_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_sig_notation {
    pub next: *mut _gpgme_sig_notation,
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub name_len: ::std::os::raw::c_int,
    pub value_len: ::std::os::raw::c_int,
    pub flags: gpgme_sig_notation_flags_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__gpgme_sig_notation() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_sig_notation>(),
        40usize,
        concat!("Size of: ", stringify!(_gpgme_sig_notation))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_sig_notation>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_sig_notation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).name_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).value_len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_sig_notation>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_sig_notation),
            "::",
            stringify!(flags)
        )
    );
}
impl _gpgme_sig_notation {
    #[inline]
    pub fn human_readable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_human_readable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn critical(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_critical(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        human_readable: ::std::os::raw::c_uint,
        critical: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let human_readable: u32 = unsafe { ::std::mem::transmute(human_readable) };
            human_readable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let critical: u32 = unsafe { ::std::mem::transmute(critical) };
            critical as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_sig_notation_t = *mut _gpgme_sig_notation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_engine_info {
    pub next: *mut _gpgme_engine_info,
    pub protocol: gpgme_protocol_t,
    pub file_name: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub req_version: *const ::std::os::raw::c_char,
    pub home_dir: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_engine_info() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_engine_info>(),
        48usize,
        concat!("Size of: ", stringify!(_gpgme_engine_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_engine_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_engine_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).protocol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).file_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(file_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).req_version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(req_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_engine_info>())).home_dir as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_engine_info),
            "::",
            stringify!(home_dir)
        )
    );
}
pub type gpgme_engine_info_t = *mut _gpgme_engine_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_tofu_info {
    pub next: *mut _gpgme_tofu_info,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub signcount: ::std::os::raw::c_ushort,
    pub encrcount: ::std::os::raw::c_ushort,
    pub signfirst: ::std::os::raw::c_ulong,
    pub signlast: ::std::os::raw::c_ulong,
    pub encrfirst: ::std::os::raw::c_ulong,
    pub encrlast: ::std::os::raw::c_ulong,
    pub description: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_tofu_info() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_tofu_info>(),
        56usize,
        concat!("Size of: ", stringify!(_gpgme_tofu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_tofu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_tofu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).signcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(signcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).encrcount as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(encrcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).signfirst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(signfirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).signlast as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(signlast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).encrfirst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(encrfirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).encrlast as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(encrlast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_tofu_info>())).description as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_tofu_info),
            "::",
            stringify!(description)
        )
    );
}
impl _gpgme_tofu_info {
    #[inline]
    pub fn validity(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_validity(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn policy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_policy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _rfu(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__rfu(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        validity: ::std::os::raw::c_uint,
        policy: ::std::os::raw::c_uint,
        _rfu: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let validity: u32 = unsafe { ::std::mem::transmute(validity) };
            validity as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let policy: u32 = unsafe { ::std::mem::transmute(policy) };
            policy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let _rfu: u32 = unsafe { ::std::mem::transmute(_rfu) };
            _rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_tofu_info_t = *mut _gpgme_tofu_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_subkey {
    pub next: *mut _gpgme_subkey,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub length: ::std::os::raw::c_uint,
    pub keyid: *mut ::std::os::raw::c_char,
    pub _keyid: [::std::os::raw::c_char; 17usize],
    pub fpr: *mut ::std::os::raw::c_char,
    pub timestamp: ::std::os::raw::c_long,
    pub expires: ::std::os::raw::c_long,
    pub card_number: *mut ::std::os::raw::c_char,
    pub curve: *mut ::std::os::raw::c_char,
    pub keygrip: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_subkey() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_subkey>(),
        104usize,
        concat!("Size of: ", stringify!(_gpgme_subkey))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_subkey>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_subkey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).pubkey_algo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(pubkey_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).keyid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>()))._keyid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(_keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).fpr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).timestamp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).expires as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).card_number as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(card_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).curve as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_subkey>())).keygrip as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_subkey),
            "::",
            stringify!(keygrip)
        )
    );
}
impl _gpgme_subkey {
    #[inline]
    pub fn revoked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_encrypt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_encrypt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_sign(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_certify(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_certify(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secret(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secret(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_authenticate(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_authenticate(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_qualified(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_qualified(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cardkey(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cardkey(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::std::os::raw::c_uint,
        expired: ::std::os::raw::c_uint,
        disabled: ::std::os::raw::c_uint,
        invalid: ::std::os::raw::c_uint,
        can_encrypt: ::std::os::raw::c_uint,
        can_sign: ::std::os::raw::c_uint,
        can_certify: ::std::os::raw::c_uint,
        secret: ::std::os::raw::c_uint,
        can_authenticate: ::std::os::raw::c_uint,
        is_qualified: ::std::os::raw::c_uint,
        is_cardkey: ::std::os::raw::c_uint,
        is_de_vs: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::std::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::std::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u32 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let invalid: u32 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_encrypt: u32 = unsafe { ::std::mem::transmute(can_encrypt) };
            can_encrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let can_sign: u32 = unsafe { ::std::mem::transmute(can_sign) };
            can_sign as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let can_certify: u32 = unsafe { ::std::mem::transmute(can_certify) };
            can_certify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let secret: u32 = unsafe { ::std::mem::transmute(secret) };
            secret as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let can_authenticate: u32 = unsafe { ::std::mem::transmute(can_authenticate) };
            can_authenticate as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_qualified: u32 = unsafe { ::std::mem::transmute(is_qualified) };
            is_qualified as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_cardkey: u32 = unsafe { ::std::mem::transmute(is_cardkey) };
            is_cardkey as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::std::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_subkey_t = *mut _gpgme_subkey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_key_sig {
    pub next: *mut _gpgme_key_sig,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub keyid: *mut ::std::os::raw::c_char,
    pub _keyid: [::std::os::raw::c_char; 17usize],
    pub timestamp: ::std::os::raw::c_long,
    pub expires: ::std::os::raw::c_long,
    pub status: gpgme_error_t,
    pub class: ::std::os::raw::c_uint,
    pub uid: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub email: *mut ::std::os::raw::c_char,
    pub comment: *mut ::std::os::raw::c_char,
    pub sig_class: ::std::os::raw::c_uint,
    pub notations: gpgme_sig_notation_t,
    pub _last_notation: gpgme_sig_notation_t,
}
#[test]
fn bindgen_test_layout__gpgme_key_sig() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_key_sig>(),
        128usize,
        concat!("Size of: ", stringify!(_gpgme_key_sig))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_key_sig>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_key_sig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).pubkey_algo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(pubkey_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).keyid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>()))._keyid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(_keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).timestamp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).expires as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).status as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).class as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).uid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).email as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).comment as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).sig_class as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(sig_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>())).notations as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(notations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key_sig>()))._last_notation as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key_sig),
            "::",
            stringify!(_last_notation)
        )
    );
}
impl _gpgme_key_sig {
    #[inline]
    pub fn revoked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exportable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exportable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::std::os::raw::c_uint,
        expired: ::std::os::raw::c_uint,
        invalid: ::std::os::raw::c_uint,
        exportable: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::std::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::std::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let invalid: u32 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exportable: u32 = unsafe { ::std::mem::transmute(exportable) };
            exportable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_key_sig_t = *mut _gpgme_key_sig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_user_id {
    pub next: *mut _gpgme_user_id,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub validity: gpgme_validity_t,
    pub uid: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub email: *mut ::std::os::raw::c_char,
    pub comment: *mut ::std::os::raw::c_char,
    pub signatures: gpgme_key_sig_t,
    pub _last_keysig: gpgme_key_sig_t,
    pub address: *mut ::std::os::raw::c_char,
    pub tofu: gpgme_tofu_info_t,
    pub last_update: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__gpgme_user_id() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_user_id>(),
        88usize,
        concat!("Size of: ", stringify!(_gpgme_user_id))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_user_id>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_user_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).validity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(validity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).email as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).comment as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).signatures as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(signatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>()))._last_keysig as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(_last_keysig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).address as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).tofu as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(tofu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_user_id>())).last_update as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_user_id),
            "::",
            stringify!(last_update)
        )
    );
}
impl _gpgme_user_id {
    #[inline]
    pub fn revoked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn origin(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_origin(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::std::os::raw::c_uint,
        invalid: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
        origin: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::std::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let invalid: u32 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 25u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let origin: u32 = unsafe { ::std::mem::transmute(origin) };
            origin as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_user_id_t = *mut _gpgme_user_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_key {
    pub _refs: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub protocol: gpgme_protocol_t,
    pub issuer_serial: *mut ::std::os::raw::c_char,
    pub issuer_name: *mut ::std::os::raw::c_char,
    pub chain_id: *mut ::std::os::raw::c_char,
    pub owner_trust: gpgme_validity_t,
    pub subkeys: gpgme_subkey_t,
    pub uids: gpgme_user_id_t,
    pub _last_subkey: gpgme_subkey_t,
    pub _last_uid: gpgme_user_id_t,
    pub keylist_mode: gpgme_keylist_mode_t,
    pub fpr: *mut ::std::os::raw::c_char,
    pub last_update: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__gpgme_key() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_key>(),
        104usize,
        concat!("Size of: ", stringify!(_gpgme_key))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_key>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>()))._refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).protocol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).issuer_serial as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(issuer_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).issuer_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(issuer_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).chain_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(chain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).owner_trust as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(owner_trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).subkeys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(subkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).uids as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(uids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>()))._last_subkey as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(_last_subkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>()))._last_uid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(_last_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).keylist_mode as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(keylist_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).fpr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_key>())).last_update as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_key),
            "::",
            stringify!(last_update)
        )
    );
}
impl _gpgme_key {
    #[inline]
    pub fn revoked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_encrypt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_encrypt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_sign(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_certify(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_certify(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secret(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secret(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_authenticate(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_authenticate(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_qualified(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_qualified(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn origin(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_origin(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::std::os::raw::c_uint,
        expired: ::std::os::raw::c_uint,
        disabled: ::std::os::raw::c_uint,
        invalid: ::std::os::raw::c_uint,
        can_encrypt: ::std::os::raw::c_uint,
        can_sign: ::std::os::raw::c_uint,
        can_certify: ::std::os::raw::c_uint,
        secret: ::std::os::raw::c_uint,
        can_authenticate: ::std::os::raw::c_uint,
        is_qualified: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
        origin: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::std::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::std::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u32 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let invalid: u32 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_encrypt: u32 = unsafe { ::std::mem::transmute(can_encrypt) };
            can_encrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let can_sign: u32 = unsafe { ::std::mem::transmute(can_sign) };
            can_sign as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let can_certify: u32 = unsafe { ::std::mem::transmute(can_certify) };
            can_certify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let secret: u32 = unsafe { ::std::mem::transmute(secret) };
            secret as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let can_authenticate: u32 = unsafe { ::std::mem::transmute(can_authenticate) };
            can_authenticate as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_qualified: u32 = unsafe { ::std::mem::transmute(is_qualified) };
            is_qualified as u64
        });
        __bindgen_bitfield_unit.set(10usize, 17u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let origin: u32 = unsafe { ::std::mem::transmute(origin) };
            origin as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_key_t = *mut _gpgme_key;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_invalid_key {
    pub next: *mut _gpgme_invalid_key,
    pub fpr: *mut ::std::os::raw::c_char,
    pub reason: gpgme_error_t,
}
#[test]
fn bindgen_test_layout__gpgme_invalid_key() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_invalid_key>(),
        24usize,
        concat!("Size of: ", stringify!(_gpgme_invalid_key))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_invalid_key>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_invalid_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_invalid_key>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_invalid_key),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_invalid_key>())).fpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_invalid_key),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_invalid_key>())).reason as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_invalid_key),
            "::",
            stringify!(reason)
        )
    );
}
pub type gpgme_invalid_key_t = *mut _gpgme_invalid_key;
pub type gpgme_passphrase_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        hook: *mut ::std::os::raw::c_void,
        uid_hint: *const ::std::os::raw::c_char,
        passphrase_info: *const ::std::os::raw::c_char,
        prev_was_bad: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_progress_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        what: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        current: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ),
>;
pub type gpgme_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        keyword: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t,
>;
pub type gpgme_interact_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        keyword: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        fd: ::std::os::raw::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_new = unsafe extern "C" fn(ctx: *mut gpgme_ctx_t) -> gpgme_error_t;
pub type gpgme_release = unsafe extern "C" fn(ctx: gpgme_ctx_t);
pub type gpgme_set_ctx_flag = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    name: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> gpgme_error_t;

pub type gpgme_get_ctx_flag = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    name: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char;
extern "C" {
    pub fn gpgme_set_protocol(ctx: gpgme_ctx_t, proto: gpgme_protocol_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_get_protocol(ctx: gpgme_ctx_t) -> gpgme_protocol_t;
}
extern "C" {
    pub fn gpgme_set_sub_protocol(ctx: gpgme_ctx_t, proto: gpgme_protocol_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_get_sub_protocol(ctx: gpgme_ctx_t) -> gpgme_protocol_t;
}
extern "C" {
    pub fn gpgme_get_protocol_name(proto: gpgme_protocol_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_set_armor(ctx: gpgme_ctx_t, yes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgme_get_armor(ctx: gpgme_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgme_set_textmode(ctx: gpgme_ctx_t, yes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgme_get_textmode(ctx: gpgme_ctx_t) -> ::std::os::raw::c_int;
}
pub type gpgme_set_offline = extern "C" fn(ctx: gpgme_ctx_t, yes: ::std::os::raw::c_int);
pub type gpgme_get_offline = extern "C" fn(ctx: gpgme_ctx_t) -> ::std::os::raw::c_int;
extern "C" {
    pub fn gpgme_set_include_certs(ctx: gpgme_ctx_t, nr_of_certs: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgme_get_include_certs(ctx: gpgme_ctx_t) -> ::std::os::raw::c_int;
}
pub type gpgme_set_keylist_mode =
    unsafe extern "C" fn(ctx: gpgme_ctx_t, mode: gpgme_keylist_mode_t) -> gpgme_error_t;
pub type gpgme_get_keylist_mode = unsafe extern "C" fn(ctx: gpgme_ctx_t) -> gpgme_keylist_mode_t;
extern "C" {
    pub fn gpgme_set_pinentry_mode(ctx: gpgme_ctx_t, mode: gpgme_pinentry_mode_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_get_pinentry_mode(ctx: gpgme_ctx_t) -> gpgme_pinentry_mode_t;
}
extern "C" {
    pub fn gpgme_set_passphrase_cb(
        ctx: gpgme_ctx_t,
        cb: gpgme_passphrase_cb_t,
        hook_value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_get_passphrase_cb(
        ctx: gpgme_ctx_t,
        cb: *mut gpgme_passphrase_cb_t,
        hook_value: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_set_progress_cb(
        c: gpgme_ctx_t,
        cb: gpgme_progress_cb_t,
        hook_value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_get_progress_cb(
        ctx: gpgme_ctx_t,
        cb: *mut gpgme_progress_cb_t,
        hook_value: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_set_status_cb(
        c: gpgme_ctx_t,
        cb: gpgme_status_cb_t,
        hook_value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_get_status_cb(
        ctx: gpgme_ctx_t,
        cb: *mut gpgme_status_cb_t,
        hook_value: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gpgme_set_locale(
        ctx: gpgme_ctx_t,
        category: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_ctx_get_engine_info(ctx: gpgme_ctx_t) -> gpgme_engine_info_t;
}
extern "C" {
    pub fn gpgme_ctx_set_engine_info(
        ctx: gpgme_ctx_t,
        proto: gpgme_protocol_t,
        file_name: *const ::std::os::raw::c_char,
        home_dir: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_signers_clear(ctx: gpgme_ctx_t);
}
extern "C" {
    pub fn gpgme_signers_add(ctx: gpgme_ctx_t, key: gpgme_key_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_signers_count(ctx: gpgme_ctx_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gpgme_signers_enum(ctx: gpgme_ctx_t, seq: ::std::os::raw::c_int) -> gpgme_key_t;
}
extern "C" {
    pub fn gpgme_sig_notation_clear(ctx: gpgme_ctx_t);
}
extern "C" {
    pub fn gpgme_sig_notation_add(
        ctx: gpgme_ctx_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: gpgme_sig_notation_flags_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_sig_notation_get(ctx: gpgme_ctx_t) -> gpgme_sig_notation_t;
}
extern "C" {
    pub fn gpgme_set_sender(
        ctx: gpgme_ctx_t,
        address: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_get_sender(ctx: gpgme_ctx_t) -> *const ::std::os::raw::c_char;
}
pub type gpgme_io_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        fd: ::std::os::raw::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_register_io_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        fd: ::std::os::raw::c_int,
        dir: ::std::os::raw::c_int,
        fnc: gpgme_io_cb_t,
        fnc_data: *mut ::std::os::raw::c_void,
        tag: *mut *mut ::std::os::raw::c_void,
    ) -> gpgme_error_t,
>;
pub type gpgme_remove_io_cb_t =
    ::std::option::Option<unsafe extern "C" fn(tag: *mut ::std::os::raw::c_void)>;
pub const gpgme_event_io_t_GPGME_EVENT_START: gpgme_event_io_t = 0;
pub const gpgme_event_io_t_GPGME_EVENT_DONE: gpgme_event_io_t = 1;
pub const gpgme_event_io_t_GPGME_EVENT_NEXT_KEY: gpgme_event_io_t = 2;
pub const gpgme_event_io_t_GPGME_EVENT_NEXT_TRUSTITEM: gpgme_event_io_t = 3;
pub type gpgme_event_io_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_io_event_done_data {
    pub err: gpgme_error_t,
    pub op_err: gpgme_error_t,
}
#[test]
fn bindgen_test_layout_gpgme_io_event_done_data() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_io_event_done_data>(),
        8usize,
        concat!("Size of: ", stringify!(gpgme_io_event_done_data))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_io_event_done_data>(),
        4usize,
        concat!("Alignment of ", stringify!(gpgme_io_event_done_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_event_done_data>())).err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_event_done_data),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_event_done_data>())).op_err as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_event_done_data),
            "::",
            stringify!(op_err)
        )
    );
}
pub type gpgme_io_event_done_data_t = *mut gpgme_io_event_done_data;
pub type gpgme_event_io_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        type_: gpgme_event_io_t,
        type_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_io_cbs {
    pub add: gpgme_register_io_cb_t,
    pub add_priv: *mut ::std::os::raw::c_void,
    pub remove: gpgme_remove_io_cb_t,
    pub event: gpgme_event_io_cb_t,
    pub event_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gpgme_io_cbs() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_io_cbs>(),
        40usize,
        concat!("Size of: ", stringify!(gpgme_io_cbs))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_io_cbs>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_io_cbs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_cbs>())).add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_cbs),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_cbs>())).add_priv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_cbs),
            "::",
            stringify!(add_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_cbs>())).remove as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_cbs),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_cbs>())).event as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_cbs),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_io_cbs>())).event_priv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_io_cbs),
            "::",
            stringify!(event_priv)
        )
    );
}
pub type gpgme_io_cbs_t = *mut gpgme_io_cbs;
pub type gpgme_set_io_cbs = unsafe extern "C" fn(ctx: gpgme_ctx_t, io_cbs: gpgme_io_cbs_t);
extern "C" {
    pub fn gpgme_get_io_cbs(ctx: gpgme_ctx_t, io_cbs: gpgme_io_cbs_t);
}
extern "C" {
    pub fn gpgme_io_read(
        fd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn gpgme_io_write(
        fd: ::std::os::raw::c_int,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn gpgme_io_writen(
        fd: ::std::os::raw::c_int,
        buffer: *const ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgme_wait(
        ctx: gpgme_ctx_t,
        status: *mut gpgme_error_t,
        hang: ::std::os::raw::c_int,
    ) -> gpgme_ctx_t;
}
extern "C" {
    pub fn gpgme_wait_ext(
        ctx: gpgme_ctx_t,
        status: *mut gpgme_error_t,
        op_err: *mut gpgme_error_t,
        hang: ::std::os::raw::c_int,
    ) -> gpgme_ctx_t;
}
extern "C" {
    pub fn gpgme_cancel(ctx: gpgme_ctx_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_cancel_async(ctx: gpgme_ctx_t) -> gpgme_error_t;
}
pub type gpgme_data_read_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgme_data_write_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgme_data_seek_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> off_t,
>;
pub type gpgme_data_release_cb_t =
    ::std::option::Option<unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_data_cbs {
    pub read: gpgme_data_read_cb_t,
    pub write: gpgme_data_write_cb_t,
    pub seek: gpgme_data_seek_cb_t,
    pub release: gpgme_data_release_cb_t,
}
#[test]
fn bindgen_test_layout_gpgme_data_cbs() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_data_cbs>(),
        32usize,
        concat!("Size of: ", stringify!(gpgme_data_cbs))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_data_cbs>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_data_cbs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_data_cbs>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_data_cbs),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_data_cbs>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_data_cbs),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_data_cbs>())).seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_data_cbs),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_data_cbs>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_data_cbs),
            "::",
            stringify!(release)
        )
    );
}
pub type gpgme_data_cbs_t = *mut gpgme_data_cbs;
pub type gpgme_data_read = unsafe extern "C" fn(
    dh: gpgme_data_t,
    buffer: *mut ::std::os::raw::c_void,
    size: usize,
) -> isize;
pub type gpgme_data_write = unsafe extern "C" fn(
    dh: gpgme_data_t,
    buffer: *const ::std::os::raw::c_void,
    size: usize,
) -> isize;
pub type gpgme_data_seek =
    unsafe extern "C" fn(dh: gpgme_data_t, offset: off_t, whence: ::std::os::raw::c_int) -> off_t;
pub type gpgme_data_new = unsafe extern "C" fn(r_dh: *mut gpgme_data_t) -> gpgme_error_t;
pub type gpgme_data_release = unsafe extern "C" fn(dh: gpgme_data_t);
pub type gpgme_data_new_from_mem = unsafe extern "C" fn(
    r_dh: *mut gpgme_data_t,
    buffer: *const ::std::os::raw::c_char,
    size: usize,
    copy: ::std::os::raw::c_int,
) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_data_release_and_get_mem(
        dh: gpgme_data_t,
        r_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_free(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgme_data_new_from_cbs(
        dh: *mut gpgme_data_t,
        cbs: gpgme_data_cbs_t,
        handle: *mut ::std::os::raw::c_void,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_new_from_fd(
        dh: *mut gpgme_data_t,
        fd: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_new_from_stream(dh: *mut gpgme_data_t, stream: *mut FILE) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_new_from_estream(
        r_dh: *mut gpgme_data_t,
        stream: gpgrt_stream_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_get_encoding(dh: gpgme_data_t) -> gpgme_data_encoding_t;
}
extern "C" {
    pub fn gpgme_data_set_encoding(dh: gpgme_data_t, enc: gpgme_data_encoding_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_get_file_name(dh: gpgme_data_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_data_set_file_name(
        dh: gpgme_data_t,
        file_name: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_set_flag(
        dh: gpgme_data_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gpgme_data_identify(
        dh: gpgme_data_t,
        reserved: ::std::os::raw::c_int,
    ) -> gpgme_data_type_t;
}
pub type gpgme_data_new_from_file = unsafe extern "C" fn(
    r_dh: *mut gpgme_data_t,
    fname: *const ::std::os::raw::c_char,
    copy: ::std::os::raw::c_int,
) -> gpgme_error_t;

extern "C" {
    pub fn gpgme_data_new_from_filepart(
        r_dh: *mut gpgme_data_t,
        fname: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        offset: off_t,
        length: usize,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_rewind(dh: gpgme_data_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_get_key(
        ctx: gpgme_ctx_t,
        fpr: *const ::std::os::raw::c_char,
        r_key: *mut gpgme_key_t,
        secret: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_key_from_uid(
        key: *mut gpgme_key_t,
        name: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
pub type gpgme_key_ref = unsafe extern "C" fn(key: gpgme_key_t);
pub type gpgme_key_unref = unsafe extern "C" fn(key: gpgme_key_t);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_encrypt_result {
    pub invalid_recipients: gpgme_invalid_key_t,
}
#[test]
fn bindgen_test_layout__gpgme_op_encrypt_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_encrypt_result>(),
        8usize,
        concat!("Size of: ", stringify!(_gpgme_op_encrypt_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_encrypt_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_encrypt_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_encrypt_result>())).invalid_recipients as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_encrypt_result),
            "::",
            stringify!(invalid_recipients)
        )
    );
}
pub type gpgme_encrypt_result_t = *mut _gpgme_op_encrypt_result;
extern "C" {
    pub fn gpgme_op_encrypt_result(ctx: gpgme_ctx_t) -> gpgme_encrypt_result_t;
}
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_ALWAYS_TRUST: gpgme_encrypt_flags_t = 1;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_NO_ENCRYPT_TO: gpgme_encrypt_flags_t = 2;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_PREPARE: gpgme_encrypt_flags_t = 4;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_EXPECT_SIGN: gpgme_encrypt_flags_t = 8;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_NO_COMPRESS: gpgme_encrypt_flags_t = 16;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_SYMMETRIC: gpgme_encrypt_flags_t = 32;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_THROW_KEYIDS: gpgme_encrypt_flags_t = 64;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_WRAP: gpgme_encrypt_flags_t = 128;
pub const gpgme_encrypt_flags_t_GPGME_ENCRYPT_WANT_ADDRESS: gpgme_encrypt_flags_t = 256;
pub type gpgme_encrypt_flags_t = u32;
extern "C" {
    pub fn gpgme_op_encrypt_start(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_ext_start(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        recpstring: *const ::std::os::raw::c_char,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_ext(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        recpstring: *const ::std::os::raw::c_char,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_sign_start(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_sign(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_sign_ext_start(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        recpstring: *const ::std::os::raw::c_char,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_encrypt_sign_ext(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        recpstring: *const ::std::os::raw::c_char,
        flags: gpgme_encrypt_flags_t,
        plain: gpgme_data_t,
        cipher: gpgme_data_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_recipient {
    pub next: *mut _gpgme_recipient,
    pub keyid: *mut ::std::os::raw::c_char,
    pub _keyid: [::std::os::raw::c_char; 17usize],
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub status: gpgme_error_t,
}
#[test]
fn bindgen_test_layout__gpgme_recipient() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_recipient>(),
        48usize,
        concat!("Size of: ", stringify!(_gpgme_recipient))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_recipient>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_recipient))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_recipient>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_recipient),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_recipient>())).keyid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_recipient),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_recipient>()))._keyid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_recipient),
            "::",
            stringify!(_keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_recipient>())).pubkey_algo as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_recipient),
            "::",
            stringify!(pubkey_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_recipient>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_recipient),
            "::",
            stringify!(status)
        )
    );
}
pub type gpgme_recipient_t = *mut _gpgme_recipient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_decrypt_result {
    pub unsupported_algorithm: *mut ::std::os::raw::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub recipients: gpgme_recipient_t,
    pub file_name: *mut ::std::os::raw::c_char,
    pub session_key: *mut ::std::os::raw::c_char,
    pub symkey_algo: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_op_decrypt_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_decrypt_result>(),
        48usize,
        concat!("Size of: ", stringify!(_gpgme_op_decrypt_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_decrypt_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_decrypt_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_decrypt_result>())).unsupported_algorithm as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_decrypt_result),
            "::",
            stringify!(unsupported_algorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_decrypt_result>())).recipients as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_decrypt_result),
            "::",
            stringify!(recipients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_decrypt_result>())).file_name as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_decrypt_result),
            "::",
            stringify!(file_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_decrypt_result>())).session_key as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_decrypt_result),
            "::",
            stringify!(session_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_decrypt_result>())).symkey_algo as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_decrypt_result),
            "::",
            stringify!(symkey_algo)
        )
    );
}
impl _gpgme_op_decrypt_result {
    #[inline]
    pub fn wrong_key_usage(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrong_key_usage(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mime(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mime(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn legacy_cipher_nomdc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_legacy_cipher_nomdc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wrong_key_usage: ::std::os::raw::c_uint,
        is_de_vs: ::std::os::raw::c_uint,
        is_mime: ::std::os::raw::c_uint,
        legacy_cipher_nomdc: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wrong_key_usage: u32 = unsafe { ::std::mem::transmute(wrong_key_usage) };
            wrong_key_usage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::std::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_mime: u32 = unsafe { ::std::mem::transmute(is_mime) };
            is_mime as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let legacy_cipher_nomdc: u32 = unsafe { ::std::mem::transmute(legacy_cipher_nomdc) };
            legacy_cipher_nomdc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_decrypt_result_t = *mut _gpgme_op_decrypt_result;
pub type gpgme_op_decrypt_result = unsafe extern "C" fn(ctx: gpgme_ctx_t) -> gpgme_decrypt_result_t;
pub const gpgme_decrypt_flags_t_GPGME_DECRYPT_VERIFY: gpgme_decrypt_flags_t = 1;
pub const gpgme_decrypt_flags_t_GPGME_DECRYPT_UNWRAP: gpgme_decrypt_flags_t = 128;
pub type gpgme_decrypt_flags_t = u32;
pub type gpgme_op_decrypt_start = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    cipher: gpgme_data_t,
    plain: gpgme_data_t,
) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_op_decrypt(
        ctx: gpgme_ctx_t,
        cipher: gpgme_data_t,
        plain: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_decrypt_verify_start(
        ctx: gpgme_ctx_t,
        cipher: gpgme_data_t,
        plain: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_decrypt_verify(
        ctx: gpgme_ctx_t,
        cipher: gpgme_data_t,
        plain: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_decrypt_ext_start(
        ctx: gpgme_ctx_t,
        flags: gpgme_decrypt_flags_t,
        cipher: gpgme_data_t,
        plain: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_decrypt_ext(
        ctx: gpgme_ctx_t,
        flags: gpgme_decrypt_flags_t,
        cipher: gpgme_data_t,
        plain: gpgme_data_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_new_signature {
    pub next: *mut _gpgme_new_signature,
    pub type_: gpgme_sig_mode_t,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub hash_algo: gpgme_hash_algo_t,
    pub _obsolete_class: ::std::os::raw::c_ulong,
    pub timestamp: ::std::os::raw::c_long,
    pub fpr: *mut ::std::os::raw::c_char,
    pub class: ::std::os::raw::c_uint,
    pub sig_class: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__gpgme_new_signature() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_new_signature>(),
        56usize,
        concat!("Size of: ", stringify!(_gpgme_new_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_new_signature>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_new_signature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_new_signature>())).pubkey_algo as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(pubkey_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).hash_algo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(hash_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_new_signature>()))._obsolete_class as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(_obsolete_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).fpr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).class as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_new_signature>())).sig_class as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_new_signature),
            "::",
            stringify!(sig_class)
        )
    );
}
pub type gpgme_new_signature_t = *mut _gpgme_new_signature;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_sign_result {
    pub invalid_signers: gpgme_invalid_key_t,
    pub signatures: gpgme_new_signature_t,
}
#[test]
fn bindgen_test_layout__gpgme_op_sign_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_sign_result>(),
        16usize,
        concat!("Size of: ", stringify!(_gpgme_op_sign_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_sign_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_sign_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_sign_result>())).invalid_signers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_sign_result),
            "::",
            stringify!(invalid_signers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_sign_result>())).signatures as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_sign_result),
            "::",
            stringify!(signatures)
        )
    );
}
pub type gpgme_sign_result_t = *mut _gpgme_op_sign_result;
extern "C" {
    pub fn gpgme_op_sign_result(ctx: gpgme_ctx_t) -> gpgme_sign_result_t;
}
pub type gpgme_op_sign_start = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    plain: gpgme_data_t,
    sig: gpgme_data_t,
    mode: gpgme_sig_mode_t,
) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_op_sign(
        ctx: gpgme_ctx_t,
        plain: gpgme_data_t,
        sig: gpgme_data_t,
        mode: gpgme_sig_mode_t,
    ) -> gpgme_error_t;
}
pub const gpgme_sigsum_t_GPGME_SIGSUM_VALID: gpgme_sigsum_t = 1;
pub const gpgme_sigsum_t_GPGME_SIGSUM_GREEN: gpgme_sigsum_t = 2;
pub const gpgme_sigsum_t_GPGME_SIGSUM_RED: gpgme_sigsum_t = 4;
pub const gpgme_sigsum_t_GPGME_SIGSUM_KEY_REVOKED: gpgme_sigsum_t = 16;
pub const gpgme_sigsum_t_GPGME_SIGSUM_KEY_EXPIRED: gpgme_sigsum_t = 32;
pub const gpgme_sigsum_t_GPGME_SIGSUM_SIG_EXPIRED: gpgme_sigsum_t = 64;
pub const gpgme_sigsum_t_GPGME_SIGSUM_KEY_MISSING: gpgme_sigsum_t = 128;
pub const gpgme_sigsum_t_GPGME_SIGSUM_CRL_MISSING: gpgme_sigsum_t = 256;
pub const gpgme_sigsum_t_GPGME_SIGSUM_CRL_TOO_OLD: gpgme_sigsum_t = 512;
pub const gpgme_sigsum_t_GPGME_SIGSUM_BAD_POLICY: gpgme_sigsum_t = 1024;
pub const gpgme_sigsum_t_GPGME_SIGSUM_SYS_ERROR: gpgme_sigsum_t = 2048;
pub const gpgme_sigsum_t_GPGME_SIGSUM_TOFU_CONFLICT: gpgme_sigsum_t = 4096;
pub type gpgme_sigsum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_signature {
    pub next: *mut _gpgme_signature,
    pub summary: gpgme_sigsum_t,
    pub fpr: *mut ::std::os::raw::c_char,
    pub status: gpgme_error_t,
    pub notations: gpgme_sig_notation_t,
    pub timestamp: ::std::os::raw::c_ulong,
    pub exp_timestamp: ::std::os::raw::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub validity: gpgme_validity_t,
    pub validity_reason: gpgme_error_t,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub hash_algo: gpgme_hash_algo_t,
    pub pka_address: *mut ::std::os::raw::c_char,
    pub key: gpgme_key_t,
}
#[test]
fn bindgen_test_layout__gpgme_signature() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_signature>(),
        96usize,
        concat!("Size of: ", stringify!(_gpgme_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_signature>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_signature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).summary as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(summary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).fpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).notations as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(notations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).timestamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).exp_timestamp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(exp_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).validity as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(validity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_signature>())).validity_reason as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(validity_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).pubkey_algo as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(pubkey_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).hash_algo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(hash_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).pka_address as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(pka_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_signature>())).key as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_signature),
            "::",
            stringify!(key)
        )
    );
}
impl _gpgme_signature {
    #[inline]
    pub fn wrong_key_usage(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrong_key_usage(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pka_trust(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pka_trust(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chain_model(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chain_model(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wrong_key_usage: ::std::os::raw::c_uint,
        pka_trust: ::std::os::raw::c_uint,
        chain_model: ::std::os::raw::c_uint,
        is_de_vs: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wrong_key_usage: u32 = unsafe { ::std::mem::transmute(wrong_key_usage) };
            wrong_key_usage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let pka_trust: u32 = unsafe { ::std::mem::transmute(pka_trust) };
            pka_trust as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let chain_model: u32 = unsafe { ::std::mem::transmute(chain_model) };
            chain_model as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::std::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_signature_t = *mut _gpgme_signature;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_verify_result {
    pub signatures: gpgme_signature_t,
    pub file_name: *mut ::std::os::raw::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__gpgme_op_verify_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_verify_result>(),
        24usize,
        concat!("Size of: ", stringify!(_gpgme_op_verify_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_verify_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_verify_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_verify_result>())).signatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_verify_result),
            "::",
            stringify!(signatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_verify_result>())).file_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_verify_result),
            "::",
            stringify!(file_name)
        )
    );
}
impl _gpgme_op_verify_result {
    #[inline]
    pub fn is_mime(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mime(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_mime: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_mime: u32 = unsafe { ::std::mem::transmute(is_mime) };
            is_mime as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_verify_result_t = *mut _gpgme_op_verify_result;
pub type gpgme_op_verify_result = unsafe extern "C" fn(ctx: gpgme_ctx_t) -> gpgme_verify_result_t;
pub type gpgme_op_verify_start = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    sig: gpgme_data_t,
    signed_text: gpgme_data_t,
    plaintext: gpgme_data_t,
) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_op_verify(
        ctx: gpgme_ctx_t,
        sig: gpgme_data_t,
        signed_text: gpgme_data_t,
        plaintext: gpgme_data_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_import_status {
    pub next: *mut _gpgme_import_status,
    pub fpr: *mut ::std::os::raw::c_char,
    pub result: gpgme_error_t,
    pub status: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__gpgme_import_status() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_import_status>(),
        24usize,
        concat!("Size of: ", stringify!(_gpgme_import_status))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_import_status>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_import_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_import_status>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_import_status),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_import_status>())).fpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_import_status),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_import_status>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_import_status),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_import_status>())).status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_import_status),
            "::",
            stringify!(status)
        )
    );
}
pub type gpgme_import_status_t = *mut _gpgme_import_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_import_result {
    pub considered: ::std::os::raw::c_int,
    pub no_user_id: ::std::os::raw::c_int,
    pub imported: ::std::os::raw::c_int,
    pub imported_rsa: ::std::os::raw::c_int,
    pub unchanged: ::std::os::raw::c_int,
    pub new_user_ids: ::std::os::raw::c_int,
    pub new_sub_keys: ::std::os::raw::c_int,
    pub new_signatures: ::std::os::raw::c_int,
    pub new_revocations: ::std::os::raw::c_int,
    pub secret_read: ::std::os::raw::c_int,
    pub secret_imported: ::std::os::raw::c_int,
    pub secret_unchanged: ::std::os::raw::c_int,
    pub skipped_new_keys: ::std::os::raw::c_int,
    pub not_imported: ::std::os::raw::c_int,
    pub imports: gpgme_import_status_t,
    pub skipped_v3_keys: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__gpgme_op_import_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_import_result>(),
        72usize,
        concat!("Size of: ", stringify!(_gpgme_op_import_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_import_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_import_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).considered as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(considered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).no_user_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(no_user_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).imported as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(imported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).imported_rsa as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(imported_rsa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).unchanged as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(unchanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).new_user_ids as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(new_user_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).new_sub_keys as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(new_sub_keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).new_signatures as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(new_signatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).new_revocations as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(new_revocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).secret_read as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(secret_read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).secret_imported as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(secret_imported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).secret_unchanged as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(secret_unchanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).skipped_new_keys as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(skipped_new_keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).not_imported as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(not_imported)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_op_import_result>())).imports as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(imports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_import_result>())).skipped_v3_keys as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_import_result),
            "::",
            stringify!(skipped_v3_keys)
        )
    );
}
pub type gpgme_import_result_t = *mut _gpgme_op_import_result;
extern "C" {
    pub fn gpgme_op_import_result(ctx: gpgme_ctx_t) -> gpgme_import_result_t;
}
extern "C" {
    pub fn gpgme_op_import_start(ctx: gpgme_ctx_t, keydata: gpgme_data_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_import(ctx: gpgme_ctx_t, keydata: gpgme_data_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_import_keys_start(ctx: gpgme_ctx_t, keys: *mut gpgme_key_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_import_keys(ctx: gpgme_ctx_t, keys: *mut gpgme_key_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export_start(
        ctx: gpgme_ctx_t,
        pattern: *const ::std::os::raw::c_char,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export(
        ctx: gpgme_ctx_t,
        pattern: *const ::std::os::raw::c_char,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export_ext_start(
        ctx: gpgme_ctx_t,
        pattern: *mut *const ::std::os::raw::c_char,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export_ext(
        ctx: gpgme_ctx_t,
        pattern: *mut *const ::std::os::raw::c_char,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export_keys_start(
        ctx: gpgme_ctx_t,
        keys: *mut gpgme_key_t,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_export_keys(
        ctx: gpgme_ctx_t,
        keys: *mut gpgme_key_t,
        mode: gpgme_export_mode_t,
        keydata: gpgme_data_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_genkey_result {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub fpr: *mut ::std::os::raw::c_char,
    pub pubkey: gpgme_data_t,
    pub seckey: gpgme_data_t,
}
#[test]
fn bindgen_test_layout__gpgme_op_genkey_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_genkey_result>(),
        32usize,
        concat!("Size of: ", stringify!(_gpgme_op_genkey_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_genkey_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_genkey_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_op_genkey_result>())).fpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_genkey_result),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_op_genkey_result>())).pubkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_genkey_result),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_op_genkey_result>())).seckey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_genkey_result),
            "::",
            stringify!(seckey)
        )
    );
}
impl _gpgme_op_genkey_result {
    #[inline]
    pub fn primary(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sub(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sub(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        primary: ::std::os::raw::c_uint,
        sub: ::std::os::raw::c_uint,
        uid: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let primary: u32 = unsafe { ::std::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sub: u32 = unsafe { ::std::mem::transmute(sub) };
            sub as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let uid: u32 = unsafe { ::std::mem::transmute(uid) };
            uid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_genkey_result_t = *mut _gpgme_op_genkey_result;
extern "C" {
    pub fn gpgme_op_genkey_start(
        ctx: gpgme_ctx_t,
        parms: *const ::std::os::raw::c_char,
        pubkey: gpgme_data_t,
        seckey: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_genkey(
        ctx: gpgme_ctx_t,
        parms: *const ::std::os::raw::c_char,
        pubkey: gpgme_data_t,
        seckey: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_createkey_start(
        ctx: gpgme_ctx_t,
        userid: *const ::std::os::raw::c_char,
        algo: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_ulong,
        expires: ::std::os::raw::c_ulong,
        certkey: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_createkey(
        ctx: gpgme_ctx_t,
        userid: *const ::std::os::raw::c_char,
        algo: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_ulong,
        expires: ::std::os::raw::c_ulong,
        certkey: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_createsubkey_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        algo: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_ulong,
        expires: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_createsubkey(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        algo: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_ulong,
        expires: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_adduid_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_adduid(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_revuid_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_revuid(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_set_uid_flag_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_set_uid_flag(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_genkey_result(ctx: gpgme_ctx_t) -> gpgme_genkey_result_t;
}
extern "C" {
    pub fn gpgme_op_delete_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        allow_secret: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_delete(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        allow_secret: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_delete_ext_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_delete_ext(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_keysign_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        expires: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_keysign(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        userid: *const ::std::os::raw::c_char,
        expires: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_interact_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
        fnc: gpgme_interact_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_interact(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
        fnc: gpgme_interact_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_tofu_policy_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        policy: gpgme_tofu_policy_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_tofu_policy(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        policy: gpgme_tofu_policy_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_keylist_result {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__gpgme_op_keylist_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_keylist_result>(),
        4usize,
        concat!("Size of: ", stringify!(_gpgme_op_keylist_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_keylist_result>(),
        4usize,
        concat!("Alignment of ", stringify!(_gpgme_op_keylist_result))
    );
}
impl _gpgme_op_keylist_result {
    #[inline]
    pub fn truncated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        truncated: ::std::os::raw::c_uint,
        _unused: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let truncated: u32 = unsafe { ::std::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let _unused: u32 = unsafe { ::std::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_keylist_result_t = *mut _gpgme_op_keylist_result;
extern "C" {
    pub fn gpgme_op_keylist_result(ctx: gpgme_ctx_t) -> gpgme_keylist_result_t;
}
pub type gpgme_op_keylist_start = unsafe extern "C" fn(
    ctx: gpgme_ctx_t,
    pattern: *const ::std::os::raw::c_char,
    secret_only: ::std::os::raw::c_int,
) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_op_keylist_ext_start(
        ctx: gpgme_ctx_t,
        pattern: *mut *const ::std::os::raw::c_char,
        secret_only: ::std::os::raw::c_int,
        reserved: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_keylist_from_data_start(
        ctx: gpgme_ctx_t,
        data: gpgme_data_t,
        reserved: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
pub type gpgme_op_keylist_next =
    unsafe extern "C" fn(ctx: gpgme_ctx_t, r_key: *mut gpgme_key_t) -> gpgme_error_t;
pub type gpgme_op_keylist_end = unsafe extern "C" fn(ctx: gpgme_ctx_t) -> gpgme_error_t;
extern "C" {
    pub fn gpgme_op_passwd_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_passwd(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_trust_item {
    pub _refs: ::std::os::raw::c_uint,
    pub keyid: *mut ::std::os::raw::c_char,
    pub _keyid: [::std::os::raw::c_char; 17usize],
    pub type_: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub owner_trust: *mut ::std::os::raw::c_char,
    pub _owner_trust: [::std::os::raw::c_char; 2usize],
    pub validity: *mut ::std::os::raw::c_char,
    pub _validity: [::std::os::raw::c_char; 2usize],
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_trust_item() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_trust_item>(),
        88usize,
        concat!("Size of: ", stringify!(_gpgme_trust_item))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_trust_item>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_trust_item))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>()))._refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).keyid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>()))._keyid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(_keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).type_ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).owner_trust as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(owner_trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>()))._owner_trust as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(_owner_trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).validity as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(validity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>()))._validity as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(_validity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_trust_item>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_trust_item),
            "::",
            stringify!(name)
        )
    );
}
pub type gpgme_trust_item_t = *mut _gpgme_trust_item;
extern "C" {
    pub fn gpgme_op_trustlist_start(
        ctx: gpgme_ctx_t,
        pattern: *const ::std::os::raw::c_char,
        max_level: ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_trustlist_next(
        ctx: gpgme_ctx_t,
        r_item: *mut gpgme_trust_item_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_trustlist_end(ctx: gpgme_ctx_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_trust_item_ref(item: gpgme_trust_item_t);
}
extern "C" {
    pub fn gpgme_trust_item_unref(item: gpgme_trust_item_t);
}
extern "C" {
    pub fn gpgme_op_getauditlog_start(
        ctx: gpgme_ctx_t,
        output: gpgme_data_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_getauditlog(
        ctx: gpgme_ctx_t,
        output: gpgme_data_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_spawn_start(
        ctx: gpgme_ctx_t,
        file: *const ::std::os::raw::c_char,
        argv: *mut *const ::std::os::raw::c_char,
        datain: gpgme_data_t,
        dataout: gpgme_data_t,
        dataerr: gpgme_data_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_spawn(
        ctx: gpgme_ctx_t,
        file: *const ::std::os::raw::c_char,
        argv: *mut *const ::std::os::raw::c_char,
        datain: gpgme_data_t,
        dataout: gpgme_data_t,
        dataerr: gpgme_data_t,
        flags: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
pub type gpgme_assuan_data_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_void,
        datalen: usize,
    ) -> gpgme_error_t,
>;
pub type gpgme_assuan_inquire_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        r_data: *mut gpgme_data_t,
    ) -> gpgme_error_t,
>;
pub type gpgme_assuan_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        status: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t,
>;
extern "C" {
    pub fn gpgme_op_assuan_transact_start(
        ctx: gpgme_ctx_t,
        command: *const ::std::os::raw::c_char,
        data_cb: gpgme_assuan_data_cb_t,
        data_cb_value: *mut ::std::os::raw::c_void,
        inq_cb: gpgme_assuan_inquire_cb_t,
        inq_cb_value: *mut ::std::os::raw::c_void,
        stat_cb: gpgme_assuan_status_cb_t,
        stat_cb_value: *mut ::std::os::raw::c_void,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_assuan_transact_ext(
        ctx: gpgme_ctx_t,
        command: *const ::std::os::raw::c_char,
        data_cb: gpgme_assuan_data_cb_t,
        data_cb_value: *mut ::std::os::raw::c_void,
        inq_cb: gpgme_assuan_inquire_cb_t,
        inq_cb_value: *mut ::std::os::raw::c_void,
        stat_cb: gpgme_assuan_status_cb_t,
        stat_cb_value: *mut ::std::os::raw::c_void,
        op_err: *mut gpgme_error_t,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_vfs_mount_result {
    pub mount_dir: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__gpgme_op_vfs_mount_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_vfs_mount_result>(),
        8usize,
        concat!("Size of: ", stringify!(_gpgme_op_vfs_mount_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_vfs_mount_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_vfs_mount_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_vfs_mount_result>())).mount_dir as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_vfs_mount_result),
            "::",
            stringify!(mount_dir)
        )
    );
}
pub type gpgme_vfs_mount_result_t = *mut _gpgme_op_vfs_mount_result;
extern "C" {
    pub fn gpgme_op_vfs_mount_result(ctx: gpgme_ctx_t) -> gpgme_vfs_mount_result_t;
}
extern "C" {
    pub fn gpgme_op_vfs_mount(
        ctx: gpgme_ctx_t,
        container_file: *const ::std::os::raw::c_char,
        mount_dir: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        op_err: *mut gpgme_error_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_vfs_create(
        ctx: gpgme_ctx_t,
        recp: *mut gpgme_key_t,
        container_file: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        op_err: *mut gpgme_error_t,
    ) -> gpgme_error_t;
}
pub const gpgme_conf_level_t_GPGME_CONF_BASIC: gpgme_conf_level_t = 0;
pub const gpgme_conf_level_t_GPGME_CONF_ADVANCED: gpgme_conf_level_t = 1;
pub const gpgme_conf_level_t_GPGME_CONF_EXPERT: gpgme_conf_level_t = 2;
pub const gpgme_conf_level_t_GPGME_CONF_INVISIBLE: gpgme_conf_level_t = 3;
pub const gpgme_conf_level_t_GPGME_CONF_INTERNAL: gpgme_conf_level_t = 4;
pub type gpgme_conf_level_t = u32;
pub const gpgme_conf_type_t_GPGME_CONF_NONE: gpgme_conf_type_t = 0;
pub const gpgme_conf_type_t_GPGME_CONF_STRING: gpgme_conf_type_t = 1;
pub const gpgme_conf_type_t_GPGME_CONF_INT32: gpgme_conf_type_t = 2;
pub const gpgme_conf_type_t_GPGME_CONF_UINT32: gpgme_conf_type_t = 3;
pub const gpgme_conf_type_t_GPGME_CONF_FILENAME: gpgme_conf_type_t = 32;
pub const gpgme_conf_type_t_GPGME_CONF_LDAP_SERVER: gpgme_conf_type_t = 33;
pub const gpgme_conf_type_t_GPGME_CONF_KEY_FPR: gpgme_conf_type_t = 34;
pub const gpgme_conf_type_t_GPGME_CONF_PUB_KEY: gpgme_conf_type_t = 35;
pub const gpgme_conf_type_t_GPGME_CONF_SEC_KEY: gpgme_conf_type_t = 36;
pub const gpgme_conf_type_t_GPGME_CONF_ALIAS_LIST: gpgme_conf_type_t = 37;
pub type gpgme_conf_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgme_conf_arg {
    pub next: *mut gpgme_conf_arg,
    pub no_arg: ::std::os::raw::c_uint,
    pub value: gpgme_conf_arg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgme_conf_arg__bindgen_ty_1 {
    pub count: ::std::os::raw::c_uint,
    pub uint32: ::std::os::raw::c_uint,
    pub int32: ::std::os::raw::c_int,
    pub string: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gpgme_conf_arg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_conf_arg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gpgme_conf_arg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_conf_arg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_conf_arg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_arg__bindgen_ty_1>())).count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_arg__bindgen_ty_1>())).uint32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_arg__bindgen_ty_1>())).int32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg__bindgen_ty_1),
            "::",
            stringify!(int32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_arg__bindgen_ty_1>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
}
#[test]
fn bindgen_test_layout_gpgme_conf_arg() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_conf_arg>(),
        24usize,
        concat!("Size of: ", stringify!(gpgme_conf_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_conf_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_conf_arg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_arg>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_arg>())).no_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg),
            "::",
            stringify!(no_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_arg>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_arg),
            "::",
            stringify!(value)
        )
    );
}
pub type gpgme_conf_arg_t = *mut gpgme_conf_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_conf_opt {
    pub next: *mut gpgme_conf_opt,
    pub name: *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub level: gpgme_conf_level_t,
    pub description: *mut ::std::os::raw::c_char,
    pub type_: gpgme_conf_type_t,
    pub alt_type: gpgme_conf_type_t,
    pub argname: *mut ::std::os::raw::c_char,
    pub default_value: gpgme_conf_arg_t,
    pub default_description: *mut ::std::os::raw::c_char,
    pub no_arg_value: gpgme_conf_arg_t,
    pub no_arg_description: *mut ::std::os::raw::c_char,
    pub value: gpgme_conf_arg_t,
    pub change_value: ::std::os::raw::c_int,
    pub new_value: gpgme_conf_arg_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gpgme_conf_opt() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_conf_opt>(),
        112usize,
        concat!("Size of: ", stringify!(gpgme_conf_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_conf_opt>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_conf_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).level as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).alt_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(alt_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).argname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(argname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).default_value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_opt>())).default_description as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(default_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).no_arg_value as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(no_arg_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgme_conf_opt>())).no_arg_description as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(no_arg_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).change_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(change_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).new_value as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(new_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_opt>())).user_data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_opt),
            "::",
            stringify!(user_data)
        )
    );
}
pub type gpgme_conf_opt_t = *mut gpgme_conf_opt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_conf_comp {
    pub next: *mut gpgme_conf_comp,
    pub _last_opt_p: *mut gpgme_conf_opt_t,
    pub name: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub program_name: *mut ::std::os::raw::c_char,
    pub options: *mut gpgme_conf_opt,
}
#[test]
fn bindgen_test_layout_gpgme_conf_comp() {
    assert_eq!(
        ::std::mem::size_of::<gpgme_conf_comp>(),
        48usize,
        concat!("Size of: ", stringify!(gpgme_conf_comp))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgme_conf_comp>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgme_conf_comp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>()))._last_opt_p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(_last_opt_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>())).program_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(program_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgme_conf_comp>())).options as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgme_conf_comp),
            "::",
            stringify!(options)
        )
    );
}
pub type gpgme_conf_comp_t = *mut gpgme_conf_comp;
extern "C" {
    pub fn gpgme_conf_arg_new(
        arg_p: *mut gpgme_conf_arg_t,
        type_: gpgme_conf_type_t,
        value: *const ::std::os::raw::c_void,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_conf_arg_release(arg: gpgme_conf_arg_t, type_: gpgme_conf_type_t);
}
extern "C" {
    pub fn gpgme_conf_opt_change(
        opt: gpgme_conf_opt_t,
        reset: ::std::os::raw::c_int,
        arg: gpgme_conf_arg_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_conf_release(conf: gpgme_conf_comp_t);
}
extern "C" {
    pub fn gpgme_op_conf_load(ctx: gpgme_ctx_t, conf_p: *mut gpgme_conf_comp_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_conf_save(ctx: gpgme_ctx_t, comp: gpgme_conf_comp_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_conf_dir(
        ctx: gpgme_ctx_t,
        what: *const ::std::os::raw::c_char,
        result: *mut *mut ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_query_swdb_result {
    pub next: *mut _gpgme_op_query_swdb_result,
    pub name: *mut ::std::os::raw::c_char,
    pub iversion: *mut ::std::os::raw::c_char,
    pub created: ::std::os::raw::c_ulong,
    pub retrieved: ::std::os::raw::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub version: *mut ::std::os::raw::c_char,
    pub reldate: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__gpgme_op_query_swdb_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_query_swdb_result>(),
        64usize,
        concat!("Size of: ", stringify!(_gpgme_op_query_swdb_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_query_swdb_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgme_op_query_swdb_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).iversion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(iversion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).created as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).retrieved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(retrieved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).version as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgme_op_query_swdb_result>())).reldate as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_query_swdb_result),
            "::",
            stringify!(reldate)
        )
    );
}
impl _gpgme_op_query_swdb_result {
    #[inline]
    pub fn warning(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_warning(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urgent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_urgent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noinfo(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noinfo(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unknown(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tooold(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tooold(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        warning: ::std::os::raw::c_uint,
        update: ::std::os::raw::c_uint,
        urgent: ::std::os::raw::c_uint,
        noinfo: ::std::os::raw::c_uint,
        unknown: ::std::os::raw::c_uint,
        tooold: ::std::os::raw::c_uint,
        error: ::std::os::raw::c_uint,
        _reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let warning: u32 = unsafe { ::std::mem::transmute(warning) };
            warning as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update: u32 = unsafe { ::std::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let urgent: u32 = unsafe { ::std::mem::transmute(urgent) };
            urgent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let noinfo: u32 = unsafe { ::std::mem::transmute(noinfo) };
            noinfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unknown: u32 = unsafe { ::std::mem::transmute(unknown) };
            unknown as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tooold: u32 = unsafe { ::std::mem::transmute(tooold) };
            tooold as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let _reserved: u32 = unsafe { ::std::mem::transmute(_reserved) };
            _reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgme_query_swdb_result_t = *mut _gpgme_op_query_swdb_result;
extern "C" {
    pub fn gpgme_op_query_swdb(
        ctx: gpgme_ctx_t,
        name: *const ::std::os::raw::c_char,
        iversion: *const ::std::os::raw::c_char,
        reserved: ::std::os::raw::c_uint,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_query_swdb_result(ctx: gpgme_ctx_t) -> gpgme_query_swdb_result_t;
}
extern "C" {
    pub fn gpgme_set_global_flag(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type gpgme_check_version = unsafe extern "C" fn(
    req_version: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char;
extern "C" {
    pub fn gpgme_check_version_internal(
        req_version: *const ::std::os::raw::c_char,
        offset_sig_validity: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_get_dirinfo(what: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_get_engine_info(engine_info: *mut gpgme_engine_info_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_set_engine_info(
        proto: gpgme_protocol_t,
        file_name: *const ::std::os::raw::c_char,
        home_dir: *const ::std::os::raw::c_char,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_engine_check_version(proto: gpgme_protocol_t) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_result_ref(result: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgme_result_unref(result: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgme_pubkey_algo_string(subkey: gpgme_subkey_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_pubkey_algo_name(algo: gpgme_pubkey_algo_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_hash_algo_name(algo: gpgme_hash_algo_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_addrspec_from_uid(
        uid: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub const gpgme_status_code_t_GPGME_STATUS_EOF: gpgme_status_code_t = 0;
pub const gpgme_status_code_t_GPGME_STATUS_ENTER: gpgme_status_code_t = 1;
pub const gpgme_status_code_t_GPGME_STATUS_LEAVE: gpgme_status_code_t = 2;
pub const gpgme_status_code_t_GPGME_STATUS_ABORT: gpgme_status_code_t = 3;
pub const gpgme_status_code_t_GPGME_STATUS_GOODSIG: gpgme_status_code_t = 4;
pub const gpgme_status_code_t_GPGME_STATUS_BADSIG: gpgme_status_code_t = 5;
pub const gpgme_status_code_t_GPGME_STATUS_ERRSIG: gpgme_status_code_t = 6;
pub const gpgme_status_code_t_GPGME_STATUS_BADARMOR: gpgme_status_code_t = 7;
pub const gpgme_status_code_t_GPGME_STATUS_RSA_OR_IDEA: gpgme_status_code_t = 8;
pub const gpgme_status_code_t_GPGME_STATUS_KEYEXPIRED: gpgme_status_code_t = 9;
pub const gpgme_status_code_t_GPGME_STATUS_KEYREVOKED: gpgme_status_code_t = 10;
pub const gpgme_status_code_t_GPGME_STATUS_TRUST_UNDEFINED: gpgme_status_code_t = 11;
pub const gpgme_status_code_t_GPGME_STATUS_TRUST_NEVER: gpgme_status_code_t = 12;
pub const gpgme_status_code_t_GPGME_STATUS_TRUST_MARGINAL: gpgme_status_code_t = 13;
pub const gpgme_status_code_t_GPGME_STATUS_TRUST_FULLY: gpgme_status_code_t = 14;
pub const gpgme_status_code_t_GPGME_STATUS_TRUST_ULTIMATE: gpgme_status_code_t = 15;
pub const gpgme_status_code_t_GPGME_STATUS_SHM_INFO: gpgme_status_code_t = 16;
pub const gpgme_status_code_t_GPGME_STATUS_SHM_GET: gpgme_status_code_t = 17;
pub const gpgme_status_code_t_GPGME_STATUS_SHM_GET_BOOL: gpgme_status_code_t = 18;
pub const gpgme_status_code_t_GPGME_STATUS_SHM_GET_HIDDEN: gpgme_status_code_t = 19;
pub const gpgme_status_code_t_GPGME_STATUS_NEED_PASSPHRASE: gpgme_status_code_t = 20;
pub const gpgme_status_code_t_GPGME_STATUS_VALIDSIG: gpgme_status_code_t = 21;
pub const gpgme_status_code_t_GPGME_STATUS_SIG_ID: gpgme_status_code_t = 22;
pub const gpgme_status_code_t_GPGME_STATUS_ENC_TO: gpgme_status_code_t = 23;
pub const gpgme_status_code_t_GPGME_STATUS_NODATA: gpgme_status_code_t = 24;
pub const gpgme_status_code_t_GPGME_STATUS_BAD_PASSPHRASE: gpgme_status_code_t = 25;
pub const gpgme_status_code_t_GPGME_STATUS_NO_PUBKEY: gpgme_status_code_t = 26;
pub const gpgme_status_code_t_GPGME_STATUS_NO_SECKEY: gpgme_status_code_t = 27;
pub const gpgme_status_code_t_GPGME_STATUS_NEED_PASSPHRASE_SYM: gpgme_status_code_t = 28;
pub const gpgme_status_code_t_GPGME_STATUS_DECRYPTION_FAILED: gpgme_status_code_t = 29;
pub const gpgme_status_code_t_GPGME_STATUS_DECRYPTION_OKAY: gpgme_status_code_t = 30;
pub const gpgme_status_code_t_GPGME_STATUS_MISSING_PASSPHRASE: gpgme_status_code_t = 31;
pub const gpgme_status_code_t_GPGME_STATUS_GOOD_PASSPHRASE: gpgme_status_code_t = 32;
pub const gpgme_status_code_t_GPGME_STATUS_GOODMDC: gpgme_status_code_t = 33;
pub const gpgme_status_code_t_GPGME_STATUS_BADMDC: gpgme_status_code_t = 34;
pub const gpgme_status_code_t_GPGME_STATUS_ERRMDC: gpgme_status_code_t = 35;
pub const gpgme_status_code_t_GPGME_STATUS_IMPORTED: gpgme_status_code_t = 36;
pub const gpgme_status_code_t_GPGME_STATUS_IMPORT_OK: gpgme_status_code_t = 37;
pub const gpgme_status_code_t_GPGME_STATUS_IMPORT_PROBLEM: gpgme_status_code_t = 38;
pub const gpgme_status_code_t_GPGME_STATUS_IMPORT_RES: gpgme_status_code_t = 39;
pub const gpgme_status_code_t_GPGME_STATUS_FILE_START: gpgme_status_code_t = 40;
pub const gpgme_status_code_t_GPGME_STATUS_FILE_DONE: gpgme_status_code_t = 41;
pub const gpgme_status_code_t_GPGME_STATUS_FILE_ERROR: gpgme_status_code_t = 42;
pub const gpgme_status_code_t_GPGME_STATUS_BEGIN_DECRYPTION: gpgme_status_code_t = 43;
pub const gpgme_status_code_t_GPGME_STATUS_END_DECRYPTION: gpgme_status_code_t = 44;
pub const gpgme_status_code_t_GPGME_STATUS_BEGIN_ENCRYPTION: gpgme_status_code_t = 45;
pub const gpgme_status_code_t_GPGME_STATUS_END_ENCRYPTION: gpgme_status_code_t = 46;
pub const gpgme_status_code_t_GPGME_STATUS_DELETE_PROBLEM: gpgme_status_code_t = 47;
pub const gpgme_status_code_t_GPGME_STATUS_GET_BOOL: gpgme_status_code_t = 48;
pub const gpgme_status_code_t_GPGME_STATUS_GET_LINE: gpgme_status_code_t = 49;
pub const gpgme_status_code_t_GPGME_STATUS_GET_HIDDEN: gpgme_status_code_t = 50;
pub const gpgme_status_code_t_GPGME_STATUS_GOT_IT: gpgme_status_code_t = 51;
pub const gpgme_status_code_t_GPGME_STATUS_PROGRESS: gpgme_status_code_t = 52;
pub const gpgme_status_code_t_GPGME_STATUS_SIG_CREATED: gpgme_status_code_t = 53;
pub const gpgme_status_code_t_GPGME_STATUS_SESSION_KEY: gpgme_status_code_t = 54;
pub const gpgme_status_code_t_GPGME_STATUS_NOTATION_NAME: gpgme_status_code_t = 55;
pub const gpgme_status_code_t_GPGME_STATUS_NOTATION_DATA: gpgme_status_code_t = 56;
pub const gpgme_status_code_t_GPGME_STATUS_POLICY_URL: gpgme_status_code_t = 57;
pub const gpgme_status_code_t_GPGME_STATUS_BEGIN_STREAM: gpgme_status_code_t = 58;
pub const gpgme_status_code_t_GPGME_STATUS_END_STREAM: gpgme_status_code_t = 59;
pub const gpgme_status_code_t_GPGME_STATUS_KEY_CREATED: gpgme_status_code_t = 60;
pub const gpgme_status_code_t_GPGME_STATUS_USERID_HINT: gpgme_status_code_t = 61;
pub const gpgme_status_code_t_GPGME_STATUS_UNEXPECTED: gpgme_status_code_t = 62;
pub const gpgme_status_code_t_GPGME_STATUS_INV_RECP: gpgme_status_code_t = 63;
pub const gpgme_status_code_t_GPGME_STATUS_NO_RECP: gpgme_status_code_t = 64;
pub const gpgme_status_code_t_GPGME_STATUS_ALREADY_SIGNED: gpgme_status_code_t = 65;
pub const gpgme_status_code_t_GPGME_STATUS_SIGEXPIRED: gpgme_status_code_t = 66;
pub const gpgme_status_code_t_GPGME_STATUS_EXPSIG: gpgme_status_code_t = 67;
pub const gpgme_status_code_t_GPGME_STATUS_EXPKEYSIG: gpgme_status_code_t = 68;
pub const gpgme_status_code_t_GPGME_STATUS_TRUNCATED: gpgme_status_code_t = 69;
pub const gpgme_status_code_t_GPGME_STATUS_ERROR: gpgme_status_code_t = 70;
pub const gpgme_status_code_t_GPGME_STATUS_NEWSIG: gpgme_status_code_t = 71;
pub const gpgme_status_code_t_GPGME_STATUS_REVKEYSIG: gpgme_status_code_t = 72;
pub const gpgme_status_code_t_GPGME_STATUS_SIG_SUBPACKET: gpgme_status_code_t = 73;
pub const gpgme_status_code_t_GPGME_STATUS_NEED_PASSPHRASE_PIN: gpgme_status_code_t = 74;
pub const gpgme_status_code_t_GPGME_STATUS_SC_OP_FAILURE: gpgme_status_code_t = 75;
pub const gpgme_status_code_t_GPGME_STATUS_SC_OP_SUCCESS: gpgme_status_code_t = 76;
pub const gpgme_status_code_t_GPGME_STATUS_CARDCTRL: gpgme_status_code_t = 77;
pub const gpgme_status_code_t_GPGME_STATUS_BACKUP_KEY_CREATED: gpgme_status_code_t = 78;
pub const gpgme_status_code_t_GPGME_STATUS_PKA_TRUST_BAD: gpgme_status_code_t = 79;
pub const gpgme_status_code_t_GPGME_STATUS_PKA_TRUST_GOOD: gpgme_status_code_t = 80;
pub const gpgme_status_code_t_GPGME_STATUS_PLAINTEXT: gpgme_status_code_t = 81;
pub const gpgme_status_code_t_GPGME_STATUS_INV_SGNR: gpgme_status_code_t = 82;
pub const gpgme_status_code_t_GPGME_STATUS_NO_SGNR: gpgme_status_code_t = 83;
pub const gpgme_status_code_t_GPGME_STATUS_SUCCESS: gpgme_status_code_t = 84;
pub const gpgme_status_code_t_GPGME_STATUS_DECRYPTION_INFO: gpgme_status_code_t = 85;
pub const gpgme_status_code_t_GPGME_STATUS_PLAINTEXT_LENGTH: gpgme_status_code_t = 86;
pub const gpgme_status_code_t_GPGME_STATUS_MOUNTPOINT: gpgme_status_code_t = 87;
pub const gpgme_status_code_t_GPGME_STATUS_PINENTRY_LAUNCHED: gpgme_status_code_t = 88;
pub const gpgme_status_code_t_GPGME_STATUS_ATTRIBUTE: gpgme_status_code_t = 89;
pub const gpgme_status_code_t_GPGME_STATUS_BEGIN_SIGNING: gpgme_status_code_t = 90;
pub const gpgme_status_code_t_GPGME_STATUS_KEY_NOT_CREATED: gpgme_status_code_t = 91;
pub const gpgme_status_code_t_GPGME_STATUS_INQUIRE_MAXLEN: gpgme_status_code_t = 92;
pub const gpgme_status_code_t_GPGME_STATUS_FAILURE: gpgme_status_code_t = 93;
pub const gpgme_status_code_t_GPGME_STATUS_KEY_CONSIDERED: gpgme_status_code_t = 94;
pub const gpgme_status_code_t_GPGME_STATUS_TOFU_USER: gpgme_status_code_t = 95;
pub const gpgme_status_code_t_GPGME_STATUS_TOFU_STATS: gpgme_status_code_t = 96;
pub const gpgme_status_code_t_GPGME_STATUS_TOFU_STATS_LONG: gpgme_status_code_t = 97;
pub const gpgme_status_code_t_GPGME_STATUS_NOTATION_FLAGS: gpgme_status_code_t = 98;
pub const gpgme_status_code_t_GPGME_STATUS_DECRYPTION_COMPLIANCE_MODE: gpgme_status_code_t = 99;
pub const gpgme_status_code_t_GPGME_STATUS_VERIFICATION_COMPLIANCE_MODE: gpgme_status_code_t = 100;
pub type gpgme_status_code_t = u32;
pub type gpgme_edit_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        status: gpgme_status_code_t,
        args: *const ::std::os::raw::c_char,
        fd: ::std::os::raw::c_int,
    ) -> gpgme_error_t,
>;
extern "C" {
    pub fn gpgme_op_edit_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        fnc: gpgme_edit_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_edit(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        fnc: gpgme_edit_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_card_edit_start(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        fnc: gpgme_edit_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_op_card_edit(
        ctx: gpgme_ctx_t,
        key: gpgme_key_t,
        fnc: gpgme_edit_cb_t,
        fnc_value: *mut ::std::os::raw::c_void,
        out: gpgme_data_t,
    ) -> gpgme_error_t;
}
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_NONE: _gpgme_sig_stat_t = 0;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_GOOD: _gpgme_sig_stat_t = 1;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_BAD: _gpgme_sig_stat_t = 2;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_NOKEY: _gpgme_sig_stat_t = 3;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_NOSIG: _gpgme_sig_stat_t = 4;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_ERROR: _gpgme_sig_stat_t = 5;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_DIFF: _gpgme_sig_stat_t = 6;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_GOOD_EXP: _gpgme_sig_stat_t = 7;
pub const _gpgme_sig_stat_t_GPGME_SIG_STAT_GOOD_EXPKEY: _gpgme_sig_stat_t = 8;
pub type _gpgme_sig_stat_t = u32;
pub use self::_gpgme_sig_stat_t as gpgme_sig_stat_t;
pub const _gpgme_attr_t_GPGME_ATTR_KEYID: _gpgme_attr_t = 1;
pub const _gpgme_attr_t_GPGME_ATTR_FPR: _gpgme_attr_t = 2;
pub const _gpgme_attr_t_GPGME_ATTR_ALGO: _gpgme_attr_t = 3;
pub const _gpgme_attr_t_GPGME_ATTR_LEN: _gpgme_attr_t = 4;
pub const _gpgme_attr_t_GPGME_ATTR_CREATED: _gpgme_attr_t = 5;
pub const _gpgme_attr_t_GPGME_ATTR_EXPIRE: _gpgme_attr_t = 6;
pub const _gpgme_attr_t_GPGME_ATTR_OTRUST: _gpgme_attr_t = 7;
pub const _gpgme_attr_t_GPGME_ATTR_USERID: _gpgme_attr_t = 8;
pub const _gpgme_attr_t_GPGME_ATTR_NAME: _gpgme_attr_t = 9;
pub const _gpgme_attr_t_GPGME_ATTR_EMAIL: _gpgme_attr_t = 10;
pub const _gpgme_attr_t_GPGME_ATTR_COMMENT: _gpgme_attr_t = 11;
pub const _gpgme_attr_t_GPGME_ATTR_VALIDITY: _gpgme_attr_t = 12;
pub const _gpgme_attr_t_GPGME_ATTR_LEVEL: _gpgme_attr_t = 13;
pub const _gpgme_attr_t_GPGME_ATTR_TYPE: _gpgme_attr_t = 14;
pub const _gpgme_attr_t_GPGME_ATTR_IS_SECRET: _gpgme_attr_t = 15;
pub const _gpgme_attr_t_GPGME_ATTR_KEY_REVOKED: _gpgme_attr_t = 16;
pub const _gpgme_attr_t_GPGME_ATTR_KEY_INVALID: _gpgme_attr_t = 17;
pub const _gpgme_attr_t_GPGME_ATTR_UID_REVOKED: _gpgme_attr_t = 18;
pub const _gpgme_attr_t_GPGME_ATTR_UID_INVALID: _gpgme_attr_t = 19;
pub const _gpgme_attr_t_GPGME_ATTR_KEY_CAPS: _gpgme_attr_t = 20;
pub const _gpgme_attr_t_GPGME_ATTR_CAN_ENCRYPT: _gpgme_attr_t = 21;
pub const _gpgme_attr_t_GPGME_ATTR_CAN_SIGN: _gpgme_attr_t = 22;
pub const _gpgme_attr_t_GPGME_ATTR_CAN_CERTIFY: _gpgme_attr_t = 23;
pub const _gpgme_attr_t_GPGME_ATTR_KEY_EXPIRED: _gpgme_attr_t = 24;
pub const _gpgme_attr_t_GPGME_ATTR_KEY_DISABLED: _gpgme_attr_t = 25;
pub const _gpgme_attr_t_GPGME_ATTR_SERIAL: _gpgme_attr_t = 26;
pub const _gpgme_attr_t_GPGME_ATTR_ISSUER: _gpgme_attr_t = 27;
pub const _gpgme_attr_t_GPGME_ATTR_CHAINID: _gpgme_attr_t = 28;
pub const _gpgme_attr_t_GPGME_ATTR_SIG_STATUS: _gpgme_attr_t = 29;
pub const _gpgme_attr_t_GPGME_ATTR_ERRTOK: _gpgme_attr_t = 30;
pub const _gpgme_attr_t_GPGME_ATTR_SIG_SUMMARY: _gpgme_attr_t = 31;
pub const _gpgme_attr_t_GPGME_ATTR_SIG_CLASS: _gpgme_attr_t = 32;
pub type _gpgme_attr_t = u32;
pub use self::_gpgme_attr_t as gpgme_attr_t;
extern "C" {
    pub fn gpgme_get_sig_status(
        ctx: gpgme_ctx_t,
        idx: ::std::os::raw::c_int,
        r_stat: *mut _gpgme_sig_stat_t,
        r_created: *mut time_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_get_sig_ulong_attr(
        c: gpgme_ctx_t,
        idx: ::std::os::raw::c_int,
        what: _gpgme_attr_t,
        whatidx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn gpgme_get_sig_string_attr(
        c: gpgme_ctx_t,
        idx: ::std::os::raw::c_int,
        what: _gpgme_attr_t,
        whatidx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_get_sig_key(
        ctx: gpgme_ctx_t,
        idx: ::std::os::raw::c_int,
        r_key: *mut gpgme_key_t,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_data_new_with_read_cb(
        r_dh: *mut gpgme_data_t,
        read_cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: usize,
                arg4: *mut usize,
            ) -> ::std::os::raw::c_int,
        >,
        read_cb_value: *mut ::std::os::raw::c_void,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_key_get_string_attr(
        key: gpgme_key_t,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_key_get_ulong_attr(
        key: gpgme_key_t,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn gpgme_key_sig_get_string_attr(
        key: gpgme_key_t,
        uid_idx: ::std::os::raw::c_int,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_key_sig_get_ulong_attr(
        key: gpgme_key_t,
        uid_idx: ::std::os::raw::c_int,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn gpgme_op_import_ext(
        ctx: gpgme_ctx_t,
        keydata: gpgme_data_t,
        nr: *mut ::std::os::raw::c_int,
    ) -> gpgme_error_t;
}
extern "C" {
    pub fn gpgme_trust_item_release(item: gpgme_trust_item_t);
}
extern "C" {
    pub fn gpgme_trust_item_get_string_attr(
        item: gpgme_trust_item_t,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgme_trust_item_get_int_attr(
        item: gpgme_trust_item_t,
        what: _gpgme_attr_t,
        reserved: *const ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgme_op_assuan_result {
    pub err: gpgme_error_t,
}
#[test]
fn bindgen_test_layout__gpgme_op_assuan_result() {
    assert_eq!(
        ::std::mem::size_of::<_gpgme_op_assuan_result>(),
        4usize,
        concat!("Size of: ", stringify!(_gpgme_op_assuan_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgme_op_assuan_result>(),
        4usize,
        concat!("Alignment of ", stringify!(_gpgme_op_assuan_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgme_op_assuan_result>())).err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgme_op_assuan_result),
            "::",
            stringify!(err)
        )
    );
}
pub type gpgme_assuan_result_t = *mut _gpgme_op_assuan_result;
extern "C" {
    pub fn gpgme_op_assuan_result(ctx: gpgme_ctx_t) -> gpgme_assuan_result_t;
}
extern "C" {
    pub fn gpgme_op_assuan_transact(
        ctx: gpgme_ctx_t,
        command: *const ::std::os::raw::c_char,
        data_cb: gpgme_assuan_data_cb_t,
        data_cb_value: *mut ::std::os::raw::c_void,
        inq_cb: gpgme_assuan_inquire_cb_t,
        inq_cb_value: *mut ::std::os::raw::c_void,
        status_cb: gpgme_assuan_status_cb_t,
        status_cb_value: *mut ::std::os::raw::c_void,
    ) -> gpgme_error_t;
}
pub type GpgmeCtx = gpgme_ctx_t;
pub type GpgmeData = gpgme_data_t;
pub type GpgmeError = gpgme_error_t;
pub use self::gpgme_attr_t as GpgmeAttr;
pub use self::gpgme_data_encoding_t as GpgmeDataEncoding;
pub use self::gpgme_hash_algo_t as GpgmeHashAlgo;
pub use self::gpgme_protocol_t as GpgmeProtocol;
pub use self::gpgme_pubkey_algo_t as GpgmePubKeyAlgo;
pub use self::gpgme_sig_mode_t as GpgmeSigMode;
pub use self::gpgme_sig_stat_t as GpgmeSigStat;
pub use self::gpgme_validity_t as GpgmeValidity;
pub type GpgmeEngineInfo = gpgme_engine_info_t;
pub type GpgmeSubkey = gpgme_subkey_t;
pub type GpgmeKeySig = gpgme_key_sig_t;
pub type GpgmeUserID = gpgme_user_id_t;
pub type GpgmeKey = gpgme_key_t;
pub type GpgmePassphraseCb = gpgme_passphrase_cb_t;
pub type GpgmeProgressCb = gpgme_progress_cb_t;
pub type GpgmeIOCb = gpgme_io_cb_t;
pub type GpgmeRegisterIOCb = gpgme_register_io_cb_t;
pub type GpgmeRemoveIOCb = gpgme_remove_io_cb_t;
pub use self::gpgme_event_io_t as GpgmeEventIO;
pub type GpgmeEventIOCb = gpgme_event_io_cb_t;
pub type GpgmeDataReadCb = gpgme_data_read_cb_t;
pub type GpgmeDataWriteCb = gpgme_data_write_cb_t;
pub type GpgmeDataSeekCb = gpgme_data_seek_cb_t;
pub type GpgmeDataReleaseCb = gpgme_data_release_cb_t;
pub type GpgmeEncryptResult = gpgme_encrypt_result_t;
pub type GpgmeSigNotation = gpgme_sig_notation_t;
pub type GpgmeSignature = gpgme_signature_t;
pub type GpgmeVerifyResult = gpgme_verify_result_t;
pub type GpgmeImportStatus = gpgme_import_status_t;
pub type GpgmeImportResult = gpgme_import_result_t;
pub type GpgmeGenKeyResult = gpgme_genkey_result_t;
pub type GpgmeTrustItem = gpgme_trust_item_t;
pub use self::gpgme_status_code_t as GpgmeStatusCode;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
